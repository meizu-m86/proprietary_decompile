/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_2F34();
// int __fastcall _cxa_finalize(void *);
// int __fastcall _cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// int __fastcall _register_atfork(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall property_get(_DWORD, _DWORD, _DWORD); weak
// int atoi(const char *nptr);
// int access(const char *name, int type);
// int mkdir(const char *path, __mode_t mode);
// FILE *fopen(const char *filename, const char *modes);
// int __fastcall _fwrite_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int fclose(FILE *stream);
// int __fastcall _errno(_DWORD); weak
// char *strerror(int errnum);
// int _android_log_print(_DWORD, _DWORD, const char *, ...); weak
// int __fastcall mixer_open(_DWORD); weak
// int __fastcall mixer_get_ctl_by_name(_DWORD); weak
// int __fastcall mixer_close(_DWORD); weak
// int usleep(__useconds_t useconds);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
void __fastcall j_audio_route_free(_DWORD *a1);
_DWORD *__fastcall j_audio_route_init(int a1, const char *a2);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall pcm_is_ready(_DWORD); weak
// int __fastcall pcm_prepare(_DWORD); weak
unsigned int __fastcall j_audio_route_reset(int a1);
int __fastcall j_audio_route_apply_path(int, char *s2); // idb
int __fastcall j_audio_route_update_mixer(int a1);
// int __fastcall NxpTfa98xx_StartUp(_DWORD); weak
// int __fastcall pcm_get_error(_DWORD); weak
// int __fastcall pcm_close(_DWORD); weak
// int __fastcall property_set(_DWORD, _DWORD); weak
// int __fastcall _fread_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int fseek(FILE *stream, int off, int whence);
// int __fastcall pcm_params_get(_DWORD, _DWORD, _DWORD); weak
// int __fastcall pcm_params_free(_DWORD); weak
// int __fastcall pcm_get_buffer_size(_DWORD); weak
// int __fastcall pcm_frames_to_bytes(_DWORD, _DWORD); weak
// void *malloc(size_t size);
// __sighandler_t signal(int sig, __sighandler_t handler);
// void free(void *ptr);
// int __fastcall pcm_write(_DWORD, _DWORD, _DWORD); weak
// int __fastcall NxpTfa98xx_ReCalibrate(_DWORD); weak
int __fastcall j_wav_player_start(const char *, int, int);
// int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int __fastcall mixer_ctl_get_num_values(_DWORD); weak
// int __fastcall mixer_ctl_set_value(_DWORD, _DWORD, _DWORD); weak
// int pcm_params_get_min(void); weak
// int __fastcall pcm_params_get_max(_DWORD, _DWORD); weak
// int strcmp(const char *s1, const char *s2);
// void *calloc(size_t nmemb, size_t size);
// int Open(void); weak
int __fastcall j_thread_refresh_audio_route(pthread_mutex_t *a1);
// int NxpTfa98xx_Stop(void); weak
// int __fastcall pcm_stop(_DWORD); weak
// int __fastcall SetAudioClock(_DWORD); weak
// int __fastcall str_parms_create_str(_DWORD); weak
// int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall str_parms_destroy(_DWORD); weak
// int __fastcall str_parms_to_str(_DWORD); weak
// char *strdup(const char *s);
// float NxpTfa98xx_GetSpeakerImpedance(void); weak
// int _sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...); weak
int __fastcall j_cvq_init(int);
// int __fastcall SetAudioVolume(_DWORD); weak
int __fastcall j_get_output_device_id(int a1, unsigned int a2);
int __fastcall j_get_input_source_id(int a1, int a2);
// void __fastcall _aeabi_memclr8(void *, size_t); idb
// int __fastcall NxpTfa98xx_SetMute(_DWORD); weak
// int NxpTfa98xx_PowerOn(_DWORD, const char *, ...); weak
// int pthread_join(pthread_t th, void **thread_return);
// int release_resampler(void); weak
// int __fastcall NxpTfa98xx_PowerOff(_DWORD); weak
// int open(const char *file, int oflag, ...);
// int __fastcall _read_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// double log10(double x);
bool j_is_headphone_on(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
int __fastcall j_amplifier_calibrate(int *a1);
// int __fastcall SetAudioLoopback(_DWORD, _DWORD); weak
// int __fastcall mixer_ctl_set_enum_by_string(_DWORD, _DWORD); weak
// int str_parms_create(void); weak
// size_t strlen(const char *s);
// int __fastcall _strcat_chk(_DWORD, _DWORD, _DWORD); weak
// int __fastcall str_parms_add_str(_DWORD, _DWORD, _DWORD); weak
// void __fastcall _aeabi_memclr(void *, size_t); idb
// int __fastcall create_resampler(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __fastcall j_pcm_data_dump(const char *a1, int a2, int a3, int a4);
// int __fastcall pcm_get_htimestamp(_DWORD, _DWORD, _DWORD); weak
// int __fastcall pcm_read(_DWORD, _DWORD, _DWORD); weak
// void __fastcall _aeabi_memcpy(void *, const void *, size_t); idb
// int __fastcall mixer_ctl_set_array(_DWORD); weak
// void __fastcall _aeabi_memcpy4(void *, const void *, size_t); idb
// int mixer_get_num_ctls(void); weak
// int __fastcall mixer_get_ctl(_DWORD, _DWORD); weak
// int __fastcall mixer_ctl_get_type(_DWORD); weak
// int __fastcall mixer_ctl_get_value(_DWORD, _DWORD); weak
// int __fastcall mixer_ctl_get_array(_DWORD, _DWORD, _DWORD); weak
// XML_Parser XML_ParserCreate(const XML_Char *encoding);
// void XML_SetUserData(XML_Parser parser, void *userData);
// void XML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start, XML_EndElementHandler end);
// void *XML_GetBuffer(XML_Parser parser, int len);
// enum XML_Status XML_ParseBuffer(XML_Parser parser, int len, int isFinal);
// void XML_ParserFree(XML_Parser parser);
// int __fastcall mixer_ctl_get_num_enums(_DWORD); weak
// int __fastcall mixer_ctl_get_enum_string(_DWORD, _DWORD); weak
// void *realloc(void *ptr, size_t size);
// int __fastcall mixer_ctl_get_name(_DWORD); weak
// int printf(const char *format, ...);
// int puts(const char *s);
// void __fastcall _aeabi_memcpy8(void *, const void *, size_t); idb
int __fastcall j_set_value(const char *, const char *);
int __fastcall j_uart_dev_read_wrapper(int, int, int, int, int);
int __fastcall j_cvq_start_decode(pthread_t *);
int __fastcall j_uart_read_wrapper(_DWORD *, char *, size_t);
// void abort(void);
// int fprintf(FILE *stream, const char *format, ...);
// int __fastcall dladdr(_DWORD, _DWORD); weak
// int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
int sub_3500();
int (*__fastcall sub_3520(int (*result)(void)))(void);
int __fastcall sub_354C(void *a1);
int __fastcall sub_3598(int a1, int a2, int a3);
int __fastcall pcm_data_dump(const char *a1, int a2, int a3, int a4);
int __fastcall get_output_device_id(int a1, unsigned int a2);
int __fastcall get_input_source_id(int a1, int a2);
int __fastcall thread_refresh_audio_route(pthread_mutex_t *a1);
int __fastcall test_set_hifi_gain(int result);
int __fastcall wav_player_stop(int result);
int __fastcall wav_player_start(const char *a1, int a2, int a3);
bool is_headphone_on();
int __fastcall amplifier_calibrate(int *a1);
int thread_test_hifi(); // weak
int __fastcall adev_set_headset_volume(int a1, float a2);
unsigned int __fastcall sub_427C(int a1);
int __fastcall set_headphone_volume(audio_device *a1);
unsigned int __fastcall sub_4364(int a1, int a2, int a3);
int *__fastcall sub_4394(int a1);
int __fastcall sub_43AC(int a1, int a2, unsigned int a3, const char *a4, const char *a5);
int __fastcall adev_open(struct hw_module_t *a1, char *s1, audio_device **a3);
int __fastcall sub_46E0(audio_device *a1);
int sub_470A(); // weak
int __fastcall adev_set_voice_volume(audio_device *a1, float a2);
int sub_4824(); // weak
int __fastcall adev_set_mode(audio_device *a1, int a2);
int __fastcall sub_4B34(audio_device *a1, char a2);
int __fastcall sub_4B3C(audio_device *a1, _BYTE *a2);
int __fastcall sub_4B48(audio_device *a1, const char *a2);
char *__fastcall sub_4E6C(audio_device *a1, const char *a2);
int __fastcall sub_4FD0(int a1, int *a2);
int __fastcall adev_open_output_stream(audio_device *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __fastcall sub_52B8(audio_device *a1, stream_out *a2);
int __fastcall sub_52F4(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
void __fastcall sub_5520(int a1, stream_in *a2);
int sub_55A0(); // weak
int __fastcall sub_55A4(int a1, int a2, int a3);
int __fastcall set_voice_volume(audio_device *a1);
int __fastcall sub_569C(int a1);
int __fastcall sub_5730(audio_device *a1);
void __fastcall sub_605C(int a1);
int __fastcall sub_6164(int a1);
int __fastcall sub_61B8(stream_out *a1);
int __fastcall sub_629C(int a1);
int __fastcall sub_62E0(audio_device *a1);
int __fastcall sub_6644(stream_out *a1);
int __fastcall sub_6676(stream_in *a1);
int __fastcall sub_66B0(audio_device *a1, int a2);
struct pcm *__fastcall sub_6CBC(audio_device *a1);
int __fastcall sub_6D54(int result, const char **a2, int a3);
int __fastcall sub_6E08(int a1);
int __fastcall sub_6E0E(int a1, int a2);
unsigned int __fastcall sub_6E16(int a1);
int __fastcall sub_6E22(int a1);
int __fastcall sub_6E28(int a1);
int sub_6E2E(); // weak
int sub_6E34(); // weak
int __fastcall sub_6E38(int a1, int a2);
char *__fastcall sub_723C(int a1, const char *a2);
int sub_7320(); // weak
int sub_7324(); // weak
unsigned int __fastcall sub_7328(_DWORD *a1);
int sub_733E(); // weak
unsigned int __fastcall sub_7344(stream_out *a1, int a2, unsigned int a3);
int sub_7C90(); // weak
int sub_7C96(); // weak
int __fastcall sub_7C9C(int a1, _QWORD *a2, int a3);
unsigned int __fastcall sub_7D2C(stream_out *a1);
int __fastcall sub_7DAC(int a1);
int sub_7DB2();
int sub_7DB8(); // weak
int sub_7DE0();
int sub_7DE4();
int sub_7DE8();
int sub_7DEE();
int __fastcall sub_7DF4(int a1, int a2);
int sub_7F78(); // weak
int sub_7F84();
int sub_7F88();
int sub_7F8C();
unsigned int __fastcall sub_7F90(int a1, char *a2, unsigned int a3);
int sub_8A54();
int __fastcall sub_8A58(int a1);
int __fastcall sub_8BD4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_8C90(int result, int a2);
int __fastcall audio_route_update_mixer(int a1);
unsigned int __fastcall audio_route_reset(int a1);
int __fastcall audio_route_apply_path(int, char *s2); // idb
const char **__fastcall sub_8DE4(int a1, char *s2);
int __fastcall audio_route_reset_path(int, char *s2); // idb
_DWORD *__fastcall audio_route_init(int a1, const char *a2);
int __fastcall sub_9130(int *a1, char *a2, const char **a3);
int __fastcall sub_9568(int result);
void __fastcall sub_9570(int a1);
void __fastcall audio_route_free(_DWORD *a1);
unsigned int __fastcall sub_95D4(int a1);
int __fastcall get_value(const char *a1, int a2);
int __fastcall set_value(const char *a1, const char *a2);
int __fastcall cvq_open(int a1);
int __fastcall cvq_close(_DWORD *a1);
int __fastcall readdirect(int a1);
size_t __fastcall cvq_read(_DWORD *a1, char *a2, int a3);
int __fastcall read_on_thread(int a1);
int __fastcall read_on_raw_data_thread(pthread_t *a1);
int __fastcall uart_dev_read_wrapper(int a1, int a2, int a3, int a4, int a5);
int __fastcall cvq_start_decode(pthread_t *a1);
int __fastcall cvq_start(pthread_t *a1);
int __fastcall uart_read_wrapper(_DWORD *a1, char *a2, size_t a3);
int __fastcall pcm_read_uart_char_dev(_DWORD *a1, _WORD *a2, int a3);
int __fastcall cvq_init(int a1);
unsigned int *__fastcall sub_9FE0(unsigned int *result, int *a2, int *a3);
int __fastcall sub_A034(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_A378(int a1, int a2, unsigned int a3, int a4, int *a5);
int __fastcall sub_A414(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_A550(int a1, int a2, int a3);
int __fastcall sub_A558(int a1, int a2);
int __fastcall sub_A5B4(int a1, int a2, int a3);
int __fastcall sub_A5BC(int a1, int a2, int a3);
int __fastcall sub_A5C4(int *a1, int a2, int a3, int a4);
int __fastcall sub_A670(const void *a1, int *a2, char a3);
void __fastcall __noreturn sub_A760(int *a1, int a2, int a3, int a4);
void __fastcall __noreturn sub_A794(const char *a1, int a2, const char *a3);
int __fastcall sub_A7C4(int a1);
int __fastcall sub_A800(int a1);
int __fastcall sub_A848(int a1, int a2);
int __fastcall sub_A85C(_DWORD *a1, int a2, int a3, int a4, int a5);
_QWORD *__fastcall sub_A874(_QWORD *result);
_QWORD *__fastcall sub_A87C(_QWORD *result);
_QWORD *__fastcall sub_A884(_QWORD *result);
void sub_A88C();
void sub_A8D0();
int __fastcall sub_A8E4(int a1, const void *a2);
int __fastcall sub_A928(int a1, int a2, _DWORD *a3);
int __fastcall sub_A956(int a1, int a2, int a3);
int __fastcall sub_A99A(int a1, int a2, _QWORD *a3);
int __fastcall sub_A9CA(int a1, int a2, int a3, int a4);
int __fastcall sub_AA02(int a1);
int __fastcall sub_AA08(int a1, int a2);
int __fastcall sub_AA26(int a1);
int __fastcall sub_AA38(int a1);
int __fastcall sub_AA3E(int a1, int a2);
int __fastcall sub_AA60(int a1, int a2);
int __fastcall sub_AAEC(int result, int a2, int a3);
int __fastcall sub_AB78(int a1, int a2);
__int64 __fastcall sub_AB9C(int a1, int a2);
int __fastcall sub_AC40(int a1, int a2, int a3, int a4);
int __fastcall sub_AD0C(_DWORD *a1);
_DWORD *__fastcall sub_AD5C(int a1, _DWORD *a2);
int __fastcall sub_AD74(int a1);
int __fastcall sub_AD8A(int a1);
int __fastcall sub_AD90(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_AE00(int *a1, int a2);
int __fastcall sub_AE76(int result);
void __fastcall __noreturn sub_AE80(const char *a1, const char *a2, int a3, const char *a4);
int __fastcall sub_AEAC(int a1);
_DWORD *__fastcall sub_AF00(int a1);
int __fastcall sub_AF58(int *a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_B0FC(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8);
int __fastcall sub_B58C(int a1);
void sub_B5A0();
void sub_B5A8();
void sub_B5B0();
_DWORD *__fastcall sub_B5B8(int *a1);
_DWORD *__fastcall sub_B5FC(int *a1);
void __fastcall j_free(void *ptr);
int __fastcall j_pthread_mutex_unlock(pthread_mutex_t *mutex);
char *__fastcall j_strdup(const char *s);
int __fastcall sub_B640(int a1);
_DWORD *__fastcall sub_B650(int *a1);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_4 = '\x01'; // weak
char byte_7 = '\0'; // weak
char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
Elf32_Sym stru_400 = { 960u, 0u, 0u, 18u, 0u, 0u }; // weak
Elf32_Sym stru_800 = { 3057u, 0u, 0u, 18u, 0u, 0u }; // weak
_UNKNOWN loc_3E7E; // weak
_UNKNOWN loc_AC44; // weak
_UNKNOWN unk_D192; // weak
_UNKNOWN unk_E9B0; // weak
_UNKNOWN unk_EC90; // weak
__int16 *off_ED40[2] = { &word_1F40, &word_10 }; // weak
_WORD word_EE88[256] =
{
  -32124,
  -31100,
  -30076,
  -29052,
  -28028,
  -27004,
  -25980,
  -24956,
  -23932,
  -22908,
  -21884,
  -20860,
  -19836,
  -18812,
  -17788,
  -16764,
  -15996,
  -15484,
  -14972,
  -14460,
  -13948,
  -13436,
  -12924,
  -12412,
  -11900,
  -11388,
  -10876,
  -10364,
  -9852,
  -9340,
  -8828,
  -8316,
  -7932,
  -7676,
  -7420,
  -7164,
  -6908,
  -6652,
  -6396,
  -6140,
  -5884,
  -5628,
  -5372,
  -5116,
  -4860,
  -4604,
  -4348,
  -4092,
  -3900,
  -3772,
  -3644,
  -3516,
  -3388,
  -3260,
  -3132,
  -3004,
  -2876,
  -2748,
  -2620,
  -2492,
  -2364,
  -2236,
  -2108,
  -1980,
  -1884,
  -1820,
  -1756,
  -1692,
  -1628,
  -1564,
  -1500,
  -1436,
  -1372,
  -1308,
  -1244,
  -1180,
  -1116,
  -1052,
  -988,
  -924,
  -876,
  -844,
  -812,
  -780,
  -748,
  -716,
  -684,
  -652,
  -620,
  -588,
  -556,
  -524,
  -492,
  -460,
  -428,
  -396,
  -372,
  -356,
  -340,
  -324,
  -308,
  -292,
  -276,
  -260,
  -244,
  -228,
  -212,
  -196,
  -180,
  -164,
  -148,
  -132,
  -120,
  -112,
  -104,
  -96,
  -88,
  -80,
  -72,
  -64,
  -56,
  -48,
  -40,
  -32,
  -24,
  -16,
  -8,
  -1,
  32124,
  31100,
  30076,
  29052,
  28028,
  27004,
  25980,
  24956,
  23932,
  22908,
  21884,
  20860,
  19836,
  18812,
  17788,
  16764,
  15996,
  15484,
  14972,
  14460,
  13948,
  13436,
  12924,
  12412,
  11900,
  11388,
  10876,
  10364,
  9852,
  9340,
  8828,
  8316,
  7932,
  7676,
  7420,
  7164,
  6908,
  6652,
  6396,
  6140,
  5884,
  5628,
  5372,
  5116,
  4860,
  4604,
  4348,
  4092,
  3900,
  3772,
  3644,
  3516,
  3388,
  3260,
  3132,
  3004,
  2876,
  2748,
  2620,
  2492,
  2364,
  2236,
  2108,
  1980,
  1884,
  1820,
  1756,
  1692,
  1628,
  1564,
  1500,
  1436,
  1372,
  1308,
  1244,
  1180,
  1116,
  1052,
  988,
  924,
  876,
  844,
  812,
  780,
  748,
  716,
  684,
  652,
  620,
  588,
  556,
  524,
  492,
  460,
  428,
  396,
  372,
  356,
  340,
  324,
  308,
  292,
  276,
  260,
  244,
  228,
  212,
  196,
  180,
  164,
  148,
  132,
  120,
  112,
  104,
  96,
  88,
  80,
  72,
  64,
  56,
  48,
  40,
  32,
  24,
  16,
  8,
  0
}; // weak
char *out_channels_name_to_enum_table = "AUDIO_CHANNEL_OUT_STEREO"; // weak
char *off_10AC4[80] =
{
  &media_speaker,
  &media_headset,
  &media_headphones,
  &bluetooth_sco,
  &speaker_and_headphones,
  &media_earpiece,
  &speaker_and_bt_sco,
  &media_speaker_mic_nr_off,
  &media_headset_mic_nr_off,
  &media_headphones_mic_nr_off,
  &bluetooth_sco,
  &speaker_and_headphones,
  &media_earpiece_mic_nr_off,
  &speaker_and_bt_sco,
  &media_speaker_xunfei,
  &media_headset_xunfei,
  &media_headphones_xunfei,
  &bluetooth_sco_xunfei,
  &speaker_and_headphones,
  &media_earpiece_xunfei,
  &speaker_and_bt_sco,
  &voice_call_speaker,
  &voice_call_headset,
  &voice_call_headphones,
  &voice_call_bluetooth_sco,
  &speaker_and_headphones,
  &voice_call_earpiece,
  &speaker_and_bt_sco,
  &voice_call_speaker,
  &voice_call_headset,
  &voice_call_headphones,
  &voice_call_bluetooth_sco_nrec_off,
  &speaker_and_headphones,
  &voice_call_earpiece,
  &speaker_and_bt_sco,
  &voice_call_wb_speaker,
  &voice_call_wb_headset,
  &voice_call_wb_headphones,
  &voice_call_wb_bluetooth_sco,
  &speaker_and_headphones,
  &voice_call_wb_earpiece,
  &speaker_and_bt_sco,
  &voice_call_wb_speaker,
  &voice_call_wb_headset,
  &voice_call_wb_headphones,
  &voice_call_wb_bluetooth_sco_nrec_off,
  &speaker_and_headphones,
  &voice_call_wb_earpiece,
  &speaker_and_bt_sco,
  &camcorder_speaker,
  &camcorder_headphones,
  &camcorder_headphones,
  &bluetooth_sco,
  &speaker_and_headphones,
  &camcorder_earpiece,
  &speaker_and_bt_sco,
  &voice_rec_speaker,
  &voice_rec_headset,
  &voice_rec_headphones,
  &bluetooth_sco,
  &speaker_and_headphones,
  &voice_rec_earpiece,
  &speaker_and_bt_sco,
  &communication_speaker,
  &communication_headset,
  &communication_headphones,
  &communication_bluetooth_sco,
  &speaker_and_headphones,
  &communication_earpiece,
  &speaker_and_bt_sco,
  "EQ1 B1 Volume",
  "EQ1 B2 Volume",
  "EQ1 B3 Volume",
  "EQ1 B4 Volume",
  "EQ1 B5 Volume",
  "EQ2 B1 Volume",
  "EQ2 B2 Volume",
  "EQ2 B3 Volume",
  "EQ2 B4 Volume",
  "EQ2 B5 Volume"
}; // weak
char *off_10BDC[10] =
{
  "EQ1 B1 Volume",
  "EQ1 B2 Volume",
  "EQ1 B3 Volume",
  "EQ1 B4 Volume",
  "EQ1 B5 Volume",
  "EQ2 B1 Volume",
  "EQ2 B2 Volume",
  "EQ2 B3 Volume",
  "EQ2 B4 Volume",
  "EQ2 B5 Volume"
}; // weak
char *off_10BF0[5] =
{
  "EQ2 B1 Volume",
  "EQ2 B2 Volume",
  "EQ2 B3 Volume",
  "EQ2 B4 Volume",
  "EQ2 B5 Volume"
}; // weak
void *off_10C0C = (void *)0xA75D; // weak
char **test_earphones_ptr[9] =
{
  &test_earphones,
  &test_headphone,
  &test_speaker,
  &test_pri_mic,
  &test_sec_mic,
  &test_ter_mic,
  &default_settings,
  &test_modem_loopback_earphone,
  &test_modem_loopback_headphone
}; // weak
char **test_headphone_ptr[8] =
{
  &test_headphone,
  &test_speaker,
  &test_pri_mic,
  &test_sec_mic,
  &test_ter_mic,
  &default_settings,
  &test_modem_loopback_earphone,
  &test_modem_loopback_headphone
}; // weak
char **test_pri_mic_ptr[6] =
{
  &test_pri_mic,
  &test_sec_mic,
  &test_ter_mic,
  &default_settings,
  &test_modem_loopback_earphone,
  &test_modem_loopback_headphone
}; // weak
char **test_sec_mic_ptr[5] =
{
  &test_sec_mic,
  &test_ter_mic,
  &default_settings,
  &test_modem_loopback_earphone,
  &test_modem_loopback_headphone
}; // weak
char **test_ter_mic_ptr[4] =
{
  &test_ter_mic,
  &default_settings,
  &test_modem_loopback_earphone,
  &test_modem_loopback_headphone
}; // weak
char **test_modem_loopback_earphone_ptr[2] = { &test_modem_loopback_earphone, &test_modem_loopback_headphone }; // weak
char **test_modem_loopback_headphone_ptr = &test_modem_loopback_headphone; // weak
void *off_11000 = &off_11000; // weak
_UNKNOWN pcm_config; // weak
void *off_1100C = (void *)0xBB80; // weak
void *off_11010 = (void *)0x1000; // weak
_UNKNOWN unk_11014; // weak
_UNKNOWN unk_11018; // weak
_UNKNOWN unk_1101C; // weak
_UNKNOWN unk_11020; // weak
_UNKNOWN unk_11024; // weak
_UNKNOWN unk_11028; // weak
_UNKNOWN unk_1102C; // weak
int pcm_config_in = 2; // weak
void *off_11034 = (void *)0xBB80; // weak
Elf32_Sym *off_11038 = &stru_400; // weak
int dword_11040 = 0; // weak
_UNKNOWN pcm_config_voice_call; // weak
int dword_1105C = 16000; // weak
_UNKNOWN pcm_config_backend; // weak
_UNKNOWN unk_11084; // weak
_UNKNOWN unk_11088; // weak
_UNKNOWN unk_1108C; // weak
_UNKNOWN unk_11090; // weak
_UNKNOWN unk_11094; // weak
_UNKNOWN unk_11098; // weak
_UNKNOWN unk_1109C; // weak
_UNKNOWN unk_110A0; // weak
_UNKNOWN unk_110A4; // weak
_UNKNOWN pcm_config_sco; // weak
_UNKNOWN pcm_config_amplifier; // weak
void *off_110D4 = (void *)0xBB80; // weak
Elf32_Sym *off_110D8 = &stru_400; // weak
_UNKNOWN unk_110DC; // weak
_UNKNOWN unk_110E0; // weak
_UNKNOWN unk_110E4; // weak
_UNKNOWN unk_110E8; // weak
_UNKNOWN unk_110EC; // weak
_UNKNOWN unk_110F0; // weak
_UNKNOWN unk_110F4; // weak
char *default_settings = "ES705 RX1 Enable"; // weak
char *test_speaker = "IN2MUX Input"; // weak
int dword_116C8; // weak
int dword_116CC; // weak
int dword_116D0; // weak
char byte_116D4; // weak
int dword_116D8; // weak
int dword_116DC; // weak
_UNKNOWN unk_116E0; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern struct _IO_FILE *stderr;


//----- (00002F34) --------------------------------------------------------
void sub_2F34()
{
  JUMPOUT(0);
}
// 2F40: control flows out of bounds to 0

//----- (0000302C) --------------------------------------------------------
// attributes: thunk
void __fastcall j_audio_route_free(_DWORD *a1)
{
  audio_route_free(a1);
}

//----- (00003038) --------------------------------------------------------
// attributes: thunk
_DWORD *__fastcall j_audio_route_init(int a1, const char *a2)
{
  return audio_route_init(a1, a2);
}

//----- (00003074) --------------------------------------------------------
// attributes: thunk
unsigned int __fastcall j_audio_route_reset(int a1)
{
  return audio_route_reset(a1);
}

//----- (00003080) --------------------------------------------------------
// attributes: thunk
int __fastcall j_audio_route_apply_path(int a1, char *s2)
{
  return audio_route_apply_path(a1, s2);
}

//----- (0000308C) --------------------------------------------------------
// attributes: thunk
int __fastcall j_audio_route_update_mixer(int a1)
{
  return audio_route_update_mixer(a1);
}

//----- (0000314C) --------------------------------------------------------
// attributes: thunk
int __fastcall j_wav_player_start(const char *a1, int a2, int a3)
{
  return wav_player_start(a1, a2, a3);
}

//----- (000031C4) --------------------------------------------------------
// attributes: thunk
int __fastcall j_thread_refresh_audio_route(pthread_mutex_t *a1)
{
  return thread_refresh_audio_route(a1);
}

//----- (00003248) --------------------------------------------------------
// attributes: thunk
int __fastcall j_cvq_init(int a1)
{
  return cvq_init(a1);
}

//----- (00003260) --------------------------------------------------------
// attributes: thunk
int __fastcall j_get_output_device_id(int a1, unsigned int a2)
{
  return get_output_device_id(a1, a2);
}

//----- (0000326C) --------------------------------------------------------
// attributes: thunk
int __fastcall j_get_input_source_id(int a1, int a2)
{
  return get_input_source_id(a1, a2);
}

//----- (000032F0) --------------------------------------------------------
// attributes: thunk
bool j_is_headphone_on(void)
{
  return is_headphone_on();
}

//----- (00003308) --------------------------------------------------------
// attributes: thunk
int __fastcall j_amplifier_calibrate(int *a1)
{
  return amplifier_calibrate(a1);
}

//----- (00003374) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_data_dump(const char *a1, int a2, int a3, int a4)
{
  return pcm_data_dump(a1, a2, a3, a4);
}

//----- (00003494) --------------------------------------------------------
// attributes: thunk
int __fastcall j_set_value(const char *a1, const char *a2)
{
  return set_value(a1, a2);
}

//----- (000034A0) --------------------------------------------------------
// attributes: thunk
int __fastcall j_uart_dev_read_wrapper(int a1, int a2, int a3, int a4, int a5)
{
  return uart_dev_read_wrapper(a1, a2, a3, a4, a5);
}

//----- (000034AC) --------------------------------------------------------
// attributes: thunk
int __fastcall j_cvq_start_decode(pthread_t *a1)
{
  return cvq_start_decode(a1);
}

//----- (000034B8) --------------------------------------------------------
// attributes: thunk
int __fastcall j_uart_read_wrapper(_DWORD *a1, char *a2, size_t a3)
{
  return uart_read_wrapper(a1, a2, a3);
}

//----- (00003500) --------------------------------------------------------
int sub_3500()
{
  return _cxa_finalize(&off_11000);
}
// 11000: using guessed type void *off_11000;

//----- (00003520) --------------------------------------------------------
int (*__fastcall sub_3520(int (*result)(void)))(void)
{
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (0000354C) --------------------------------------------------------
int __fastcall sub_354C(void *a1)
{
  return _cxa_atexit((void (__fastcall *)(void *))sub_3520, a1, &off_11000);
}
// 11000: using guessed type void *off_11000;

//----- (00003598) --------------------------------------------------------
int __fastcall sub_3598(int a1, int a2, int a3)
{
  return _register_atfork(a1, a2, a3, &off_11000);
}
// 2F60: using guessed type int __fastcall _register_atfork(_DWORD, _DWORD, _DWORD, _DWORD);
// 11000: using guessed type void *off_11000;

//----- (000035E0) --------------------------------------------------------
int __fastcall pcm_data_dump(const char *a1, int a2, int a3, int a4)
{
  int v7; // r0
  int v8; // r4
  const char *v9; // r0
  FILE *v10; // r6
  int *v11; // r0
  char *v12; // r0
  int v14; // [sp+8h] [bp-4h]
  char v15[92]; // [sp+Ch] [bp+0h] BYREF
  char v16[4100]; // [sp+68h] [bp+5Ch] BYREF

  property_get(a4, v15, "0");
  if ( atoi(v15) )
  {
    LOBYTE(v7) = *a1;
    if ( *a1 )
    {
      v8 = 0;
      do
      {
        v16[v8] = v7;
        if ( v8 && a1[v8] == 47 )
        {
          v16[v8] = 0;
          if ( access(v16, 0) && mkdir(v16, 0x1F8u) == -1 )
          {
            v11 = (int *)_errno(-1);
            v12 = strerror(*v11);
            _android_log_print(6, "audio_hw_primary", "Failed to create directory: %s", v12);
            _android_log_print(6, "audio_hw_primary", "The file path isn't valid");
            return _stack_chk_guard - v14;
          }
          v16[v8] = 47;
        }
        v9 = &a1[v8++];
        v7 = *((unsigned __int8 *)v9 + 1);
      }
      while ( v7 );
    }
    v10 = fopen(a1, "ab+");
    if ( v10 )
    {
      _fwrite_chk(a2, 1, a3, v10, -1);
      fclose(v10);
    }
    else
    {
      _android_log_print(6, "audio_hw_primary", "Failed to open the file");
    }
  }
  return _stack_chk_guard - v14;
}
// 36C4: variable 'v14' is possibly undefined
// 2F6C: using guessed type int __fastcall property_get(_DWORD, _DWORD, _DWORD);
// 2FA8: using guessed type int __fastcall _fwrite_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2FC0: using guessed type int __fastcall _errno(_DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (000036FC) --------------------------------------------------------
int __fastcall get_output_device_id(int a1, unsigned int a2)
{
  int v2; // r4
  unsigned int v4; // r0
  int result; // r0
  bool v6; // zf
  bool v7; // zf
  unsigned int v8; // r0
  bool v9; // zf

  v2 = a2;
  if ( !a2 )
    return 8;
  v4 = ((a2 - ((a2 >> 1) & 0x55555555)) & 0x33333333) + (((a2 - ((a2 >> 1) & 0x55555555)) >> 2) & 0x33333333);
  if ( (16843009 * ((v4 + (v4 >> 4)) & 0xF0F0F0F)) >> 24 != 2 )
  {
LABEL_12:
    v8 = ((v2 - (((unsigned int)v2 >> 1) & 0x55555555)) & 0x33333333)
       + (((v2 - (((unsigned int)v2 >> 1) & 0x55555555)) >> 2) & 0x33333333);
    if ( (16843009 * ((v8 + (v8 >> 4)) & 0xF0F0F0F)) >> 24 == 1 )
    {
      if ( v2 <= 15 )
      {
        result = 0;
        switch ( v2 )
        {
          case 1:
            result = 5;
            break;
          case 2:
            return result;
          case 4:
            result = 1;
            break;
          case 8:
            result = 2;
            break;
          default:
            return 8;
        }
        return result;
      }
      v9 = v2 == 16;
      if ( v2 != 16 )
        v9 = v2 == 32;
      if ( v9 || v2 == 64 )
        return 3;
    }
    return 8;
  }
  result = 4;
  v6 = a2 == 6;
  if ( a2 != 6 )
    v6 = a2 == 10;
  if ( !v6 )
  {
    if ( *(_DWORD *)(a1 + 168) != 1 )
      goto LABEL_11;
    result = 6;
    if ( a2 != 18 )
    {
      v7 = a2 == 34;
      if ( a2 != 34 )
        v7 = a2 == 66;
      if ( !v7 )
      {
LABEL_11:
        v2 = a2 & 0xFFFFFFFD;
        _android_log_print(
          2,
          "audio_hw_primary",
          "%s(): change two output devices to one: %x",
          "get_output_device_id",
          a2 & 0xFFFFFFFD);
        *(_DWORD *)(a1 + 172) = v2;
        _android_log_print(3, "audio_hw_primary", "%s(): adev->out_device=%x", "get_output_device_id", v2);
        goto LABEL_12;
      }
    }
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00003800) --------------------------------------------------------
int __fastcall get_input_source_id(int a1, int a2)
{
  int v3; // r1
  int v4; // r5
  int result; // r0

  v3 = a2 - 1;
  v4 = *(_DWORD *)(a1 + 252);
  if ( (*(_DWORD *)(a1 + 168) & 0xFFFFFFFE) == 2 )
    *(_BYTE *)(a1 + 313) = 0;
  result = 11;
  switch ( v3 )
  {
    case 0:
      _android_log_print(
        2,
        "audio_hw_primary",
        "%s(): mic_nr_off=%d",
        "get_input_source_id",
        *(unsigned __int8 *)(a1 + 184));
      result = *(unsigned __int8 *)(a1 + 184);
      break;
    case 3:
      _android_log_print(
        2,
        "audio_hw_primary",
        "%s(): voice_call_wb=%d, bluetooth_nrec=%d",
        "get_input_source_id",
        *(unsigned __int8 *)(a1 + 183),
        *(unsigned __int8 *)(a1 + 182));
      if ( *(_BYTE *)(a1 + 183) )
      {
        result = 6;
        if ( *(_BYTE *)(a1 + 182) )
          result = 5;
      }
      else
      {
        result = 4;
        if ( *(_BYTE *)(a1 + 182) )
          result = 3;
      }
      break;
    case 4:
      result = 7;
      break;
    case 5:
      _android_log_print(
        2,
        "audio_hw_primary",
        "%s(): voice recognition: rate=%d, asr_ready=%d",
        "get_input_source_id",
        off_11034,
        *(unsigned __int8 *)(a1 + 313));
      if ( v4 && *(_DWORD *)(v4 + 72) && off_11034 == (char *)&loc_3E7E + 2 )
      {
        result = 8;
      }
      else
      {
        result = *(unsigned __int8 *)(a1 + 313);
        if ( *(_BYTE *)(a1 + 313) )
          result = 2;
      }
      break;
    case 6:
      result = 9;
      break;
    default:
      return result;
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 11034: using guessed type void *off_11034;

//----- (00003908) --------------------------------------------------------
int __fastcall thread_refresh_audio_route(pthread_mutex_t *a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r6
  int ctl_by_name; // r7
  const char *v6; // r2
  int v7; // r0
  _DWORD *v8; // r0
  int v9; // r0
  int v10; // r6
  int v11; // r0
  int v12; // r7
  int started; // r5
  const char *error; // r0
  const char *v15; // r0

  _android_log_print(3, "audio_hw_primary", "%s(): enter", "thread_refresh_audio_route");
  v2 = 0;
  while ( 1 )
  {
    v3 = mixer_open(0);
    v4 = v3;
    if ( !v3 )
    {
      v6 = "%s(): Unable to open mixer";
      goto LABEL_7;
    }
    ctl_by_name = mixer_get_ctl_by_name(v3);
    mixer_close(v4);
    if ( ctl_by_name )
      break;
    usleep(0xC350u);
    if ( ++v2 >= 500 )
    {
      v6 = "%s(): Waiting for escore being ready timeout";
LABEL_7:
      v7 = 6;
      goto LABEL_24;
    }
  }
  pthread_mutex_lock(a1 + 41);
  j_audio_route_free((_DWORD *)a1[47].__private[0]);
  v8 = j_audio_route_init(0, "/system/etc/mixer_paths.xml");
  a1[47].__private[0] = (int32_t)v8;
  if ( !v8 )
    _android_log_print(6, "audio_hw_primary", "%s(): failed to open audio route", "thread_refresh_audio_route");
  pthread_mutex_unlock(a1 + 41);
  pthread_mutex_lock(a1 + 41);
  v9 = pcm_open(0, 2, 0, &pcm_config_amplifier);
  v10 = v9;
  if ( v9 && !pcm_is_ready(v9) )
  {
    error = (const char *)pcm_get_error(v10);
    _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(BACKEND) failed: %s", "amplifier_initialize", error);
    started = 0;
  }
  else
  {
    pcm_prepare(v10);
    v11 = pcm_open(0, 6, 0x10000000, &pcm_config_amplifier);
    v12 = v11;
    if ( v11 && !pcm_is_ready(v11) )
    {
      v15 = (const char *)pcm_get_error(v12);
      _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(AMPLIFIER) failed: %s", "amplifier_initialize", v15);
      started = 0;
    }
    else
    {
      pcm_prepare(v12);
      j_audio_route_reset(a1[47].__private[0]);
      j_audio_route_apply_path(a1[47].__private[0], "speaker");
      j_audio_route_update_mixer(a1[47].__private[0]);
      pthread_mutex_unlock(a1 + 41);
      usleep(0x3E8u);
      started = NxpTfa98xx_StartUp(off_110D4);
      if ( started )
        _android_log_print(6, "audio_hw_primary", "%s(): failed to bring up tfa98xx", "amplifier_initialize");
      usleep(0x3E8u);
    }
    pcm_close(v12);
  }
  pcm_close(v10);
  pthread_mutex_unlock(a1 + 41);
  if ( started )
    _android_log_print(
      6,
      "audio_hw_primary",
      "%s(): failed to bring up amplifier, speaker will be silent",
      "thread_refresh_audio_route");
  else
    property_set("primary.pa.ready", "1");
  v7 = 3;
  v6 = "%s(): leave";
LABEL_24:
  _android_log_print(v7, "audio_hw_primary", v6, "thread_refresh_audio_route");
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 2FF0: using guessed type int __fastcall mixer_open(_DWORD);
// 2FFC: using guessed type int __fastcall mixer_get_ctl_by_name(_DWORD);
// 3008: using guessed type int __fastcall mixer_close(_DWORD);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int __fastcall pcm_is_ready(_DWORD);
// 3068: using guessed type int __fastcall pcm_prepare(_DWORD);
// 3098: using guessed type int __fastcall NxpTfa98xx_StartUp(_DWORD);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 30BC: using guessed type int __fastcall property_set(_DWORD, _DWORD);
// 110D4: using guessed type void *off_110D4;

//----- (00003B64) --------------------------------------------------------
int __fastcall test_set_hifi_gain(int result)
{
  dword_116C8 = result;
  return result;
}
// 116C8: using guessed type int dword_116C8;

//----- (00003B70) --------------------------------------------------------
int __fastcall wav_player_stop(int result)
{
  dword_116CC = result;
  return result;
}
// 116CC: using guessed type int dword_116CC;

//----- (00003B7C) --------------------------------------------------------
int __fastcall wav_player_start(const char *a1, int a2, int a3)
{
  FILE *v6; // r4
  int v7; // r1
  int *v9; // r0
  char *v10; // r0
  unsigned int v11; // r10
  unsigned int v12; // r7
  int v13; // r8
  int v14; // r0
  int v15; // r0
  int v16; // r5
  int v17; // r6
  int v18; // r7
  int v19; // r10
  int v20; // r11
  int v21; // r5
  int v22; // r6
  int v23; // r5
  int buffer_size; // r0
  signed int v25; // r9
  char *v26; // r11
  int v27; // r7
  int v28; // r11
  char *v29; // r9
  int v30; // r10
  _BYTE *v31; // r3
  char *v32; // r1
  int v33; // r2
  int v34; // r6
  unsigned int v35; // r6
  int v36; // r2
  int error; // [sp+0h] [bp-90h]
  unsigned int v38; // [sp+Ch] [bp-84h]
  _BYTE *v39; // [sp+Ch] [bp-84h]
  unsigned int v40; // [sp+10h] [bp-80h]
  unsigned int size; // [sp+14h] [bp-7Ch]
  int sizea; // [sp+14h] [bp-7Ch]
  int ptra; // [sp+18h] [bp-78h]
  char *ptr; // [sp+18h] [bp-78h]
  char v45[2]; // [sp+1Ch] [bp-74h] BYREF
  unsigned __int16 v46; // [sp+1Eh] [bp-72h]
  unsigned int v47; // [sp+20h] [bp-70h]
  unsigned __int16 v48; // [sp+2Ah] [bp-66h]
  int v49; // [sp+2Ch] [bp-64h] BYREF
  int off; // [sp+30h] [bp-60h]
  int v51[3]; // [sp+34h] [bp-5Ch] BYREF
  _DWORD v52[4]; // [sp+40h] [bp-50h] BYREF
  int v53; // [sp+50h] [bp-40h]
  int v54; // [sp+54h] [bp-3Ch]
  int v55; // [sp+58h] [bp-38h]
  int v56; // [sp+5Ch] [bp-34h]

  dword_116CC = 0;
  _android_log_print(3, "audio_hw_primary", "%s(): ...", "wav_player_start");
  v6 = fopen(a1, "rb");
  if ( !v6 )
  {
    v9 = (int *)_errno(0);
    v10 = strerror(*v9);
    _android_log_print(6, "audio_hw_primary", "Unable to open file '%s' [%s]", a1, v10);
    return 1;
  }
  _fread_chk(v51, 12, 1, v6, 12);
  if ( v51[0] != 1179011410 || v51[2] != 1163280727 )
  {
    _android_log_print(6, "audio_hw_primary", "Error: '%s' is not a riff/wave file", a1);
    fclose(v6);
    return 1;
  }
  while ( 1 )
  {
    _fread_chk(&v49, 8, 1, v6, 8);
    if ( v49 != 544501094 )
      break;
    _fread_chk(v45, 16, 1, v6, 16);
    if ( (unsigned int)off >= 0x11 )
    {
      v7 = off - 16;
LABEL_5:
      fseek(v6, v7, 1);
    }
  }
  if ( v49 != 1635017060 )
  {
    v7 = off;
    goto LABEL_5;
  }
  v11 = v46;
  v12 = v48;
  size = v47;
  v52[0] = v46;
  v52[1] = v47;
  v52[2] = 1024;
  v52[3] = 4;
  if ( v48 == 16 )
  {
    v13 = a3;
    v53 = 0;
  }
  else
  {
    v13 = a3;
    if ( v48 == 24 )
    {
      v14 = 3;
LABEL_19:
      v53 = v14;
    }
    else if ( v48 == 32 )
    {
      v14 = 1;
      goto LABEL_19;
    }
  }
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v15 = pcm_params_get(a2, v13, 0);
  v16 = v15;
  if ( !v15 )
  {
    _android_log_print(6, "audio_hw_primary", "Unable to open PCM device %u.", v13);
    goto LABEL_45;
  }
  ptra = sub_43AC(v15, 6, size, "Sample rate", "Hz");
  v38 = v11;
  v17 = sub_43AC(v16, 5, v11, "Sample", " channels");
  v40 = v12;
  v18 = sub_43AC(v16, 3, v12, "Bitrate", " bits");
  v19 = sub_43AC(v16, 8, 0x400u, "Period size", "Hz");
  v20 = sub_43AC(v16, 10, 4u, "Period count", "Hz");
  pcm_params_free(v16);
  if ( (ptra & v17 & v18 & v19 & v20) == 0 )
    goto LABEL_45;
  v21 = 0;
  dword_116D0 = pcm_open(a2, v13, 0, v52);
  if ( !dword_116D0 )
  {
LABEL_40:
    error = pcm_get_error(v21);
    _android_log_print(6, "audio_hw_primary", "Unable to open PCM device %u (%s)", v13, error);
    goto LABEL_45;
  }
  if ( !pcm_is_ready() )
  {
    v21 = dword_116D0;
    goto LABEL_40;
  }
  v22 = mixer_open(1);
  if ( v22 )
  {
    _android_log_print(3, "audio_hw_primary", "%s(): set hifi gain: %d, %d", "play_sample", dword_116C8, 12);
    sub_4364(v22, (int)"Gain selection", dword_116C8);
    sub_4364(v22, (int)"Master Playback Volume", 12);
    sub_4364(v22, (int)"Filter Shape", 1);
    sub_4364(v22, (int)"bypass IIR", 1);
    sub_4364(v22, (int)"THD Compensation", 1);
    sub_4364(v22, (int)"2nd Harmonic Compensation", 0);
    sub_4364(v22, (int)"3nd Harmonic Compensation", 254);
    mixer_close(v22);
  }
  v23 = dword_116D0;
  buffer_size = pcm_get_buffer_size(dword_116D0);
  v25 = pcm_frames_to_bytes(v23, buffer_size);
  v26 = (char *)malloc(v25);
  ptr = v26;
  if ( v26 )
  {
    _android_log_print(3, "audio_hw_primary", "Playing sample: %u ch, %u hz, %u bit\n", v38, size, v40);
    signal(2, (__sighandler_t)sub_4394);
    v27 = v25 / 4;
    sizea = 3 * (v25 / 4);
    v39 = v26 + 1;
    do
    {
      if ( v40 == 24 )
      {
        v28 = v25;
        v29 = (char *)malloc(sizea);
        v30 = _fread_chk(v29, 1, sizea, v6, -1);
        if ( v28 >= 4 )
        {
          v31 = v39;
          v32 = v29 + 2;
          v33 = 0;
          do
          {
            *(v31 - 1) = *(v32 - 2);
            v34 = 3 * v33++;
            *v31 = v29[v34 + 1];
            v35 = *v32;
            v32 += 3;
            v31[1] = v35;
            v31[2] = v35 >> 7;
            v31 += 4;
          }
          while ( v33 < v27 );
        }
        free(v29);
        v25 = v28;
        v26 = ptr;
        v36 = 4 * (v30 / 3);
      }
      else
      {
        v36 = _fread_chk(v26, 1, v25, v6, -1);
      }
      if ( v36 < 1 )
        break;
      if ( pcm_write(dword_116D0, v26, v36) )
      {
        _android_log_print(6, "audio_hw_primary", "Error playing sample");
        break;
      }
    }
    while ( !dword_116CC );
    free(v26);
  }
  else
  {
    _android_log_print(6, "audio_hw_primary", "Unable to allocate %d bytes", v25);
  }
  pcm_close(dword_116D0);
  dword_116D0 = 0;
LABEL_45:
  fclose(v6);
  return 0;
}
// 2FC0: using guessed type int __fastcall _errno(_DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 2FF0: using guessed type int __fastcall mixer_open(_DWORD);
// 3008: using guessed type int __fastcall mixer_close(_DWORD);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int pcm_is_ready(void);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 30C8: using guessed type int __fastcall _fread_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 30E0: using guessed type int __fastcall pcm_params_get(_DWORD, _DWORD, _DWORD);
// 30EC: using guessed type int __fastcall pcm_params_free(_DWORD);
// 30F8: using guessed type int __fastcall pcm_get_buffer_size(_DWORD);
// 3104: using guessed type int __fastcall pcm_frames_to_bytes(_DWORD, _DWORD);
// 3134: using guessed type int __fastcall pcm_write(_DWORD, _DWORD, _DWORD);
// 116C8: using guessed type int dword_116C8;
// 116CC: using guessed type int dword_116CC;
// 116D0: using guessed type int dword_116D0;
// 3B7C: using guessed type char var_74[2];

//----- (00004088) --------------------------------------------------------
bool is_headphone_on()
{
  FILE *v0; // r4
  char nptr; // [sp+Bh] [bp-Dh] BYREF

  v0 = fopen("/sys/class/switch/h2w/state", "r");
  nptr = 0;
  if ( v0 )
  {
    _fread_chk(&nptr, 1, 1, v0, 1);
    fclose(v0);
  }
  return atoi(&nptr) != 0;
}
// 30C8: using guessed type int __fastcall _fread_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000040F8) --------------------------------------------------------
int __fastcall amplifier_calibrate(int *a1)
{
  int v2; // r0
  int v3; // r5

  if ( a1[57] && a1[61] )
  {
    j_audio_route_reset(a1[47]);
    j_audio_route_apply_path(a1[47], "speaker");
    j_audio_route_update_mixer(a1[47]);
    v2 = usleep(0x2710u);
    v3 = NxpTfa98xx_ReCalibrate(v2);
    if ( v3 )
      _android_log_print(6, "audio_hw_primary", "failed to calibrate tfa98xx: %d", v3);
    usleep(0x2710u);
    j_audio_route_reset(a1[47]);
    j_audio_route_apply_path(a1[47], "dummy");
    j_audio_route_update_mixer(a1[47]);
  }
  else
  {
    _android_log_print(6, "audio_hw_primary", "not open pcm devices yet");
    return -22;
  }
  return v3;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3140: using guessed type int __fastcall NxpTfa98xx_ReCalibrate(_DWORD);

//----- (00004198) --------------------------------------------------------
int thread_test_hifi()
{
  j_wav_player_start("/data/data/factory_test.wav", 1, 0);
  return 0;
}
// 4198: using guessed type int thread_test_hifi();

//----- (000041B0) --------------------------------------------------------
int __fastcall adev_set_headset_volume(int a1, float a2)
{
  int result; // r0
  int v4; // r2
  bool v5; // zf
  int v6; // r4
  float *i; // r7
  char v8[9]; // [sp+16h] [bp-32h] BYREF
  char v9[9]; // [sp+1Fh] [bp-29h] BYREF

  result = -22;
  v4 = *(_DWORD *)(a1 + 168);
  v5 = v4 == 2;
  if ( v4 != 2 )
    v5 = (*(_DWORD *)(a1 + 172) & 0xC) == 0;
  if ( !v5 )
  {
    v6 = 0;
    _snprintf_chk(v9, 9, 0, 9, "%f", a2);
    for ( i = (float *)&unk_E9B0; ; i += 3 )
    {
      _snprintf_chk(v8, 9, 0, 9, "%f", *i);
      if ( !strncmp(v9, v8, 9u) )
        break;
      if ( ++v6 >= 61 )
        return 0;
    }
    *(_DWORD *)(a1 + 272) = v6;
    if ( *(_BYTE *)(a1 + 289) )
      sub_427C(a1);
    else
      set_headphone_volume((audio_device *)a1);
    return 0;
  }
  return result;
}
// 3158: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0000427C) --------------------------------------------------------
unsigned int __fastcall sub_427C(int a1)
{
  int v2; // r5
  int v3; // r0

  if ( *(_DWORD *)(a1 + 292) == 3 )
  {
    v2 = 0;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 272);
    if ( v3 == 60 )
    {
      v2 = 255;
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 300) + 2 * v3;
      if ( *(_BYTE *)(a1 + 290) )
      {
        if ( v2 < 24 )
          v2 -= v2 / 2;
        else
          v2 -= 12;
      }
    }
  }
  _android_log_print(2, "audio_hw_primary", "%s(): volume=%d", "set_hifi_volume", v2);
  return sub_4364(*(_DWORD *)(a1 + 196), (int)"Master Playback Volume", v2);
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (000042F0) --------------------------------------------------------
int __fastcall set_headphone_volume(audio_device *a1)
{
  int result; // r0
  audio_mode_t amode; // r0
  int v4; // r5
  bool v5; // zf

  result = LOBYTE(a1->out_device);
  if ( (result & 0xC) != 0 )
  {
    amode = a1->amode;
    v4 = 128;
    v5 = amode == AUDIO_MODE_RINGTONE;
    if ( amode != AUDIO_MODE_RINGTONE )
      v5 = amode == AUDIO_MODE_IN_COMMUNICATION;
    if ( !v5 )
    {
      if ( amode == AUDIO_MODE_IN_CALL )
        v4 = 128 - 4 * a1->headphone_volume;
      else
        v4 = 128 - 2 * a1->headset_volume;
    }
    _android_log_print(2, "audio_hw_primary", "%s(): headphone volume=%d", "set_headphone_volume", v4);
    return sub_4364(a1->mixer, "HPOUT Digital Volume", v4);
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 4364: using guessed type int __fastcall sub_4364(_DWORD, _DWORD, _DWORD);

//----- (00004364) --------------------------------------------------------
unsigned int __fastcall sub_4364(int a1, int a2, int a3)
{
  unsigned int result; // r0
  unsigned int v5; // r5
  unsigned int i; // r6

  result = mixer_get_ctl_by_name();
  v5 = result;
  if ( result )
  {
    result = mixer_ctl_get_num_values(result);
    if ( result )
    {
      for ( i = 0; i < result; ++i )
      {
        mixer_ctl_set_value(v5, i, a3);
        result = mixer_ctl_get_num_values(v5);
      }
    }
  }
  return result;
}
// 2FFC: using guessed type int mixer_get_ctl_by_name(void);
// 3170: using guessed type int __fastcall mixer_ctl_get_num_values(_DWORD);
// 317C: using guessed type int __fastcall mixer_ctl_set_value(_DWORD, _DWORD, _DWORD);

//----- (00004394) --------------------------------------------------------
int *__fastcall sub_4394(int a1)
{
  int *result; // r0

  signal(a1, (__sighandler_t)((char *)&dword_0 + 1));
  result = &dword_116CC;
  dword_116CC = 1;
  return result;
}
// 0: using guessed type int dword_0;
// 116CC: using guessed type int dword_116CC;

//----- (000043AC) --------------------------------------------------------
int __fastcall sub_43AC(int a1, int a2, unsigned int a3, const char *a4, const char *a5)
{
  unsigned int min; // r0
  int v10; // r4
  unsigned int max; // r0

  min = pcm_params_get_min();
  if ( min <= a3 )
  {
    v10 = 1;
  }
  else
  {
    _android_log_print(6, "audio_hw_primary", "%s is %u%s, device only supports >= %u%s", a4, a3, a5, min, a5);
    v10 = 0;
  }
  max = pcm_params_get_max(a1, a2);
  if ( max < a3 )
  {
    _android_log_print(6, "audio_hw_primary", "%s is %u%s, device only supports <= %u%s", a4, a3, a5, max, a5);
    return 0;
  }
  return v10;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3188: using guessed type int pcm_params_get_min(void);
// 3194: using guessed type int __fastcall pcm_params_get_max(_DWORD, _DWORD);

//----- (00004424) --------------------------------------------------------
int __fastcall adev_open(struct hw_module_t *a1, char *s1, audio_device **a3)
{
  audio_device *v6; // r4
  int v7; // r0
  int v8; // r0
  int v9; // r0
  _BOOL4 v10; // r0
  char s1a[128]; // [sp+8h] [bp-118h] BYREF
  char v12[128]; // [sp+88h] [bp-98h] BYREF

  if ( strcmp(s1, "audio_hw_if") )
    return -22;
  v6 = (audio_device *)calloc(1u, 0x140u);
  if ( !v6 )
    return -12;
  v6->hw_device.common.tag = 1213678676;
  v6->hw_device.common.version = 512;
  v6->hw_device.common.module = a1;
  v6->hw_device.common.close = (int (__fastcall *)(struct hw_device_t *))sub_46E0;
  v6->hw_device.init_check = (int (__fastcall *)(const struct audio_hw_device *))sub_470A;
  v6->hw_device.set_voice_volume = (int (__fastcall *)(struct audio_hw_device *, float))adev_set_voice_volume;
  v6->hw_device.set_master_volume = (int (__fastcall *)(struct audio_hw_device *, float))sub_4824;
  v6->hw_device.set_mode = (int (__fastcall *)(struct audio_hw_device *, audio_mode_t))adev_set_mode;
  v6->hw_device.set_mic_mute = (int (__fastcall *)(struct audio_hw_device *, bool))sub_4B34;
  v6->hw_device.get_mic_mute = (int (__fastcall *)(const struct audio_hw_device *, bool *))sub_4B3C;
  v6->hw_device.set_parameters = (int (__fastcall *)(struct audio_hw_device *, const char *))sub_4B48;
  v6->hw_device.get_parameters = (char *(__fastcall *)(const struct audio_hw_device *, const char *))sub_4E6C;
  v6->hw_device.get_input_buffer_size = (size_t (__fastcall *)(const struct audio_hw_device *, const struct audio_config *))sub_4FD0;
  v6->hw_device.open_output_stream = (int (__fastcall *)(struct audio_hw_device *, audio_io_handle_t, audio_devices_t, audio_output_flags_t, struct audio_config *, struct audio_stream_out **, const char *))adev_open_output_stream;
  v6->hw_device.close_output_stream = (void (__fastcall *)(struct audio_hw_device *, struct audio_stream_out *))sub_52B8;
  v6->hw_device.open_input_stream = (int (__fastcall *)(struct audio_hw_device *, audio_io_handle_t, audio_devices_t, struct audio_config *, struct audio_stream_in **, audio_input_flags_t, const char *, audio_source_t))sub_52F4;
  v6->hw_device.close_input_stream = (void (__fastcall *)(struct audio_hw_device *, struct audio_stream_in *))sub_5520;
  v6->hw_device.dump = (int (__fastcall *)(const struct audio_hw_device *, int))sub_55A0;
  v6->hw_device.set_headphone_volume = (int (__fastcall *)(struct audio_hw_device *, float))adev_set_headset_volume;
  v6->hw_device.dumb2 = (int *)sub_55A4;
  v7 = j_audio_route_init(0, "/system/etc/mixer_paths.xml");
  v6->audio_route = (struct audio_route *)v7;
  if ( !v7 )
  {
    _android_log_print(6, "audio_hw_primary", "%s(): failed to open audio route, abort...", "adev_open");
LABEL_15:
    free(v6);
    return -12;
  }
  v8 = mixer_open(0);
  v6->mixer = (struct mixer *)v8;
  if ( !v8 )
  {
    _android_log_print(6, "audio_hw_primary", "%s(): failed to open mixer, abort...", "adev_open");
LABEL_14:
    j_audio_route_free(v6->audio_route);
    goto LABEL_15;
  }
  v9 = mixer_open(1);
  v6->hifi_mixer = (struct mixer *)v9;
  if ( !v9 )
  {
    _android_log_print(6, "audio_hw_primary", "%s(): failed to open HiFi mixer, abort...", "adev_open");
    mixer_close(v6->mixer);
    goto LABEL_14;
  }
  v6->v_50 = 0;
  v6->amode = AUDIO_MODE_NORMAL;
  v6->v_52 = 0;
  v6->v_53 = 0;
  v6->tfa_power_state = 0;
  v6->b_268 = 0;
  v6->sample_rate = 48000;
  v6->v_63 = 0;
  v6->hifi_state = 0;
  v6->b_290 = 0;
  v6->output_stream_state = 0;
  *(_QWORD *)&v6->hifi_gain_state = 0xFFFFFFFF00000000LL;
  v6->headset_volume = 28;
  v6->headphone_volume = 56;
  v6->v_70 = &byte_7;
  v6->v_71 = &byte_7;
  *a3 = v6;
  Open();
  j_thread_refresh_audio_route(v6);
  property_get("ro.product.locale.region", v12, "0");
  property_get("ro.product.locale.language", s1a, "0");
  _android_log_print(3, "audio_hw_primary", "%s:region=%s,language=%s", "adev_open", v12, s1a);
  v10 = strcmp(v12, "CN") || strcmp(s1a, "zh");
  v6->is_oversea = v10;
  _android_log_print(3, "audio_hw_primary", "%s:is_oversea=%d", "adev_open", v10);
  return 0;
}
// 2F6C: using guessed type int __fastcall property_get(_DWORD, _DWORD, _DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 2FF0: using guessed type int __fastcall mixer_open(_DWORD);
// 3008: using guessed type int __fastcall mixer_close(_DWORD);
// 302C: using guessed type int __fastcall j_audio_route_free(_DWORD);
// 3038: using guessed type int __fastcall j_audio_route_init(_DWORD, _DWORD);
// 31B8: using guessed type int Open(void);
// 31C4: using guessed type int __fastcall j_thread_refresh_audio_route(_DWORD);
// 41B0: using guessed type int adev_set_headset_volume();
// 46E0: using guessed type int sub_46E0();
// 470A: using guessed type int sub_470A();
// 4710: using guessed type int sub_4710();
// 4824: using guessed type int sub_4824();
// 482C: using guessed type int sub_482C();
// 4B34: using guessed type int sub_4B34();
// 4B3C: using guessed type int sub_4B3C();
// 4B48: using guessed type int sub_4B48();
// 4E6C: using guessed type int sub_4E6C();
// 4FD0: using guessed type int sub_4FD0();
// 5068: using guessed type int sub_5068(int, int, int, int, int, int);
// 52B8: using guessed type int sub_52B8();
// 52F4: using guessed type int sub_52F4(int, int, int, int, int);
// 5520: using guessed type int sub_5520();
// 55A0: using guessed type int sub_55A0();
// 55A4: using guessed type int sub_55A4();

//----- (000046E0) --------------------------------------------------------
int __fastcall sub_46E0(audio_device *a1)
{
  NxpTfa98xx_Stop();
  mixer_close(a1->hifi_mixer);
  mixer_close(a1->mixer);
  j_audio_route_free(a1->audio_route);
  free(a1);
  return 0;
}
// 3008: using guessed type int __fastcall mixer_close(_DWORD);
// 302C: using guessed type int __fastcall j_audio_route_free(_DWORD);
// 31D0: using guessed type int NxpTfa98xx_Stop(void);

//----- (0000470A) --------------------------------------------------------
int sub_470A()
{
  return 0;
}
// 470A: using guessed type int sub_470A();

//----- (00004710) --------------------------------------------------------
int __fastcall adev_set_voice_volume(audio_device *a1, float a2)
{
  int v4; // r8
  float *v5; // r9
  pthread_mutex_t *mutex; // [sp+10h] [bp-40h]
  char v8[9]; // [sp+16h] [bp-3Ah] BYREF
  char v9[9]; // [sp+1Fh] [bp-31h] BYREF

  mutex = &a1->lock;
  pthread_mutex_lock(&a1->lock);
  v4 = 0;
  _snprintf_chk(v9, 9, 0, 9, "%f", a2);
  v5 = (float *)&unk_EC90;
  do
  {
    _snprintf_chk(v8, 9, 0, 9, "%f", *(v5 - 1));
    if ( !strncmp(v9, v8, 9u) )
    {
      _android_log_print(3, "audio_hw_primary", "%s(): voice volume = %s", "adev_set_voice_volume", v9);
      if ( (a1->out_device & 0xC) != 0 )
      {
        a1->headphone_volume = v4;
      }
      else
      {
        a1->v_71 = (void *)(int)*v5;
        a1->v_70 = (void *)(int)v5[1];
      }
    }
    ++v4;
    v5 += 3;
  }
  while ( v4 != 15 );
  if ( a1->amode == AUDIO_MODE_IN_CALL )
    set_voice_volume(a1);
  pthread_mutex_unlock(mutex);
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3158: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 55E8: using guessed type int __fastcall sub_55E8(_DWORD);

//----- (00004824) --------------------------------------------------------
int sub_4824()
{
  return -38;
}
// 4824: using guessed type int sub_4824();

//----- (0000482C) --------------------------------------------------------
int __fastcall adev_set_mode(audio_device *a1, int a2)
{
  void *v_52; // r0
  audio_devices_t out_device; // r0
  int v6; // r0
  int v7; // r0
  struct pcm *pcm_voice_out; // r6
  struct pcm *v9; // r0
  int is_ready; // r0
  struct pcm *pcm_voice_in; // r6
  struct pcm *v12; // r0
  int v13; // r0
  const char *error; // r0
  const char *v15; // r0
  void *v_53; // r0
  audio_devices_t v17; // r0

  _android_log_print(3, "audio_hw_primary", "%s(): mode change: (%d >> %d)", "adev_set_mode", a1->amode, a2);
  pthread_mutex_lock(&a1->lock);
  if ( a1->amode == a2 )
    goto LABEL_37;
  a1->amode = a2;
  v_52 = a1->v_52;
  if ( a2 != 2 )
  {
    if ( v_52 )
    {
      _android_log_print(3, "audio_hw_primary", "Leaving IN_CALL state");
      a1->v_52 = 0;
      a1->v_50 = 0;
      _android_log_print(3, "audio_hw_primary", "%s():...", "end_call");
      if ( a1->pcm_voice_out )
      {
        pcm_stop();
        pcm_close(a1->pcm_voice_out);
        a1->pcm_voice_out = 0;
      }
      if ( a1->pcm_voice_in )
      {
        pcm_stop();
        pcm_close(a1->pcm_voice_in);
        a1->pcm_voice_in = 0;
      }
      if ( SetAudioClock(0) )
      {
        Open();
        v6 = SetAudioClock(0);
        _android_log_print(
          3,
          "audio_hw_primary",
          "%s(): failed to disable cp i2s clock, retry again, ret=%d",
          "end_call",
          v6);
      }
      a1->voice_call_wb = 0;
      sub_569C(a1);
    }
    goto LABEL_29;
  }
  if ( !v_52 )
  {
    _android_log_print(3, "audio_hw_primary", "Entering IN_CALL state");
    sub_569C(a1);
    out_device = a1->out_device;
    if ( out_device == 2 )
      *(_QWORD *)&a1->out_device = 0x8000000400000001LL;
    else
      a1->out_device = out_device & 0xFFFFFFFD;
    a1->v_50 = &byte_4;
    _android_log_print(3, "audio_hw_primary", "%s():...", "start_call");
    if ( SetAudioClock(1) )
    {
      Open();
      v7 = SetAudioClock(1);
      _android_log_print(
        3,
        "audio_hw_primary",
        "%s(): failed to enable cp i2s clock, retry again, ret=%d",
        "start_call",
        v7);
    }
    usleep(0x1388u);
    if ( !a1->pcm_voice_out )
    {
      pcm_voice_out = 0;
      v9 = (struct pcm *)pcm_open(0, 3, 0, &pcm_config_voice_call);
      a1->pcm_voice_out = v9;
      if ( v9 )
      {
        is_ready = pcm_is_ready();
        pcm_voice_out = a1->pcm_voice_out;
        if ( !is_ready )
        {
          error = (const char *)pcm_get_error(a1->pcm_voice_out);
          _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(VOICE_OUT) failed: %s", "start_call", error);
          goto LABEL_27;
        }
      }
      pcm_prepare(pcm_voice_out);
    }
    if ( a1->pcm_voice_in )
    {
LABEL_28:
      sub_5730(a1);
      a1->v_52 = &dword_0 + 1;
      goto LABEL_29;
    }
    pcm_voice_in = 0;
    v12 = (struct pcm *)pcm_open(0, 3, 0x10000000, &pcm_config_voice_call);
    a1->pcm_voice_in = v12;
    if ( !v12 || (v13 = pcm_is_ready(), pcm_voice_in = a1->pcm_voice_in, v13) )
    {
      pcm_prepare(pcm_voice_in);
      goto LABEL_28;
    }
    v15 = (const char *)pcm_get_error(a1->pcm_voice_in);
    _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(VOICE_IN) failed: %s", "start_call", v15);
    pcm_close(a1->pcm_voice_in);
    a1->pcm_voice_in = 0;
LABEL_27:
    pcm_close(a1->pcm_voice_out);
    a1->pcm_voice_out = 0;
    goto LABEL_28;
  }
LABEL_29:
  v_53 = a1->v_53;
  if ( a1->amode == AUDIO_MODE_IN_COMMUNICATION )
  {
    if ( !v_53 )
    {
      _android_log_print(3, "audio_hw_primary", "Entering IN_COMMUNICATION state");
      sub_569C(a1);
      v17 = a1->out_device;
      if ( v17 == 2 )
        *(_QWORD *)&a1->out_device = 0x8000000400000001LL;
      else
        a1->out_device = v17 & 0xFFFFFFFD;
      a1->v_50 = &byte_7;
      sub_5730(a1);
      a1->v_53 = &dword_0 + 1;
    }
  }
  else if ( v_53 )
  {
    _android_log_print(3, "audio_hw_primary", "Leaving IN_COMMUNICATION state");
    a1->v_53 = 0;
    a1->v_50 = 0;
    sub_569C(a1);
  }
LABEL_37:
  pthread_mutex_unlock(&a1->lock);
  return 0;
}
// 0: using guessed type int dword_0;
// 4: using guessed type char byte_4;
// 7: using guessed type char byte_7;
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int pcm_is_ready(void);
// 3068: using guessed type int __fastcall pcm_prepare(_DWORD);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 31B8: using guessed type int Open(void);
// 31DC: using guessed type int pcm_stop(void);
// 31E8: using guessed type int __fastcall SetAudioClock(_DWORD);
// 569C: using guessed type int __fastcall sub_569C(_DWORD);
// 5730: using guessed type int __fastcall sub_5730(_DWORD);

//----- (00004B34) --------------------------------------------------------
int __fastcall sub_4B34(audio_device *a1, char a2)
{
  a1->mic_mute_state = a2;
  return 0;
}

//----- (00004B3C) --------------------------------------------------------
int __fastcall sub_4B3C(audio_device *a1, _BYTE *a2)
{
  *a2 = a1->mic_mute_state;
  return 0;
}

//----- (00004B48) --------------------------------------------------------
int __fastcall sub_4B48(audio_device *a1, const char *a2)
{
  int str; // r4
  int v5; // r6
  _BOOL4 v6; // r6
  __int64 v7; // kr00_8
  int v8; // r7
  audio_devices_t out_device; // r7
  int v10; // r5
  char s1[32]; // [sp+8h] [bp-40h] BYREF

  str = str_parms_create_str(a2);
  _android_log_print(3, "audio_hw_primary", "%s(): kvpairs = %s", "adev_set_parameters", a2);
  if ( str_parms_get_str(str, "bt_headset_nrec", s1, 32) >= 0 )
    a1->bt_headset_nrec = strcmp(s1, "on") == 0;
  if ( str_parms_get_str(str, "screen_state", s1, 32) >= 0 )
    a1->screen_state = strcmp(s1, "on") != 0;
  if ( str_parms_get_str(str, "hifi_gain", s1, 32) >= 0 )
  {
    v5 = atoi(s1);
    if ( a1->hifi_gain_state != v5 )
    {
      _android_log_print(
        3,
        "audio_hw_primary",
        "%s(): hifi_gain change: (%d >> %d)",
        "adev_set_parameters",
        a1->hifi_gain_state,
        v5);
      a1->hifi_gain_state = v5;
      if ( a1->b_289 )
      {
        sub_62E0(a1);
        sub_427C(a1);
      }
    }
  }
  if ( str_parms_get_str(str, "dirac", s1, 32) >= 0 )
  {
    v6 = strcmp("close", s1) && strcmp("disable", s1) != 0;
    if ( a1->b_290 != v6 )
    {
      _android_log_print(3, "audio_hw_primary", "%s(): dirac state (%d >> %d)", "adev_set_parameters", a1->b_290, v6);
      a1->b_290 = v6;
      if ( v6 )
        sub_427C(a1);
    }
  }
  v7 = *(_QWORD *)&a1->v_63;
  if ( str_parms_get_str(str, "assistant_ready", s1, 32) >= 0 )
  {
    v8 = atoi(s1);
    if ( a1->asr_ready != v8 )
    {
      _android_log_print(
        3,
        "audio_hw_primary",
        "%s(): xunfei assistant asr_ready change: (%d >> %d)",
        "adev_set_parameters",
        a1->asr_ready,
        v8);
      a1->asr_ready = v8 != 0;
      if ( !v8 && a1->amode != AUDIO_MODE_IN_CALL )
      {
        if ( HIDWORD(v7) )
          sub_6644(HIDWORD(v7));
        if ( (_DWORD)v7 )
        {
          sub_6676(v7);
        }
        else if ( !HIDWORD(v7) )
        {
          pthread_mutex_lock(&a1->lock);
          out_device = a1->out_device;
          a1->out_device = 0;
          sub_5730(a1);
          a1->out_device = out_device;
          pthread_mutex_unlock(&a1->lock);
        }
      }
    }
  }
  if ( str_parms_get_str(str, "factory_test", s1, 32) < 0 )
  {
    if ( a1->amode == AUDIO_MODE_IN_CALL && str_parms_get_str(str, "routing", s1, 32) >= 0 && atoi(s1) == 1 )
    {
      pthread_mutex_lock(&a1->lock);
      sub_5730(a1);
      pthread_mutex_unlock(&a1->lock);
    }
    if ( str_parms_get_str(str, "voice_call_wb", s1, 32) >= 0 )
    {
      usleep(0x7530u);
      a1->voice_call_wb = strcmp(s1, "on") == 0;
      if ( a1->amode == AUDIO_MODE_IN_CALL )
      {
        pthread_mutex_lock(&a1->lock);
        sub_5730(a1);
        pthread_mutex_unlock(&a1->lock);
      }
    }
    if ( str_parms_get_str(str, "mic_nr_off", s1, 32) >= 0 )
      a1->mic_nr_off = strcmp(s1, "on") == 0;
    str_parms_destroy(str);
    return 0;
  }
  else
  {
    v10 = sub_66B0(a1, a2);
    str_parms_destroy(str);
  }
  return v10;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 31F4: using guessed type int __fastcall str_parms_create_str(_DWORD);
// 3200: using guessed type int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD);
// 320C: using guessed type int __fastcall str_parms_destroy(_DWORD);
// 427C: using guessed type int __fastcall sub_427C(_DWORD);
// 5730: using guessed type int __fastcall sub_5730(_DWORD);
// 62E0: using guessed type int __fastcall sub_62E0(_DWORD);
// 6644: using guessed type int __fastcall sub_6644(_DWORD);
// 6676: using guessed type int __fastcall sub_6676(_DWORD);
// 66B0: using guessed type int __fastcall sub_66B0(_DWORD, _DWORD);

//----- (00004E6C) --------------------------------------------------------
char *__fastcall sub_4E6C(audio_device *a1, const char *a2)
{
  int str; // r5
  int v5; // r4
  const char *v6; // r5
  int v7; // r6
  double SpeakerImpedance; // d16
  int v9; // r6
  __int64 s1[4]; // [sp+8h] [bp-38h] BYREF

  str = str_parms_create_str(a2);
  _android_log_print(3, "audio_hw_primary", "%s(): kvpairs = %s", "adev_get_parameters", a2);
  if ( str_parms_get_str(str, "ec_supported", s1, 32) < 0 )
  {
    v7 = str_parms_get_str(str, "factory_test", s1, 32);
    str_parms_destroy(str);
    if ( v7 >= 0 && !strcmp((const char *)s1, "pa_calibration") )
    {
      if ( sub_66B0(a1, "factory_test=pa_calibration") )
        SpeakerImpedance = 0.0;
      else
        SpeakerImpedance = NxpTfa98xx_GetSpeakerImpedance();
      memset(s1, 0, sizeof(s1));
      _sprintf_chk(s1, 0, 32, "speaker_impedance=%f", SpeakerImpedance);
      v9 = str_parms_create_str(s1);
      v6 = (const char *)str_parms_to_str();
      str_parms_destroy(v9);
      sub_66B0(a1, "factory_test=off");
      _android_log_print(3, "audio_hw_primary", "%s(): %s", "adev_get_parameters", v6);
    }
    else
    {
      return strdup((const char *)&unk_D192);
    }
  }
  else
  {
    str_parms_destroy(str);
    v5 = str_parms_create_str("ec_supported=yes");
    v6 = (const char *)str_parms_to_str();
    str_parms_destroy(v5);
  }
  return (char *)v6;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 31F4: using guessed type int __fastcall str_parms_create_str(_DWORD);
// 3200: using guessed type int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD);
// 320C: using guessed type int __fastcall str_parms_destroy(_DWORD);
// 3218: using guessed type int str_parms_to_str(void);
// 3230: using guessed type float NxpTfa98xx_GetSpeakerImpedance(void);
// 323C: using guessed type int _sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);
// 66B0: using guessed type int __fastcall sub_66B0(_DWORD, _DWORD);

//----- (00004FD0) --------------------------------------------------------
int __fastcall sub_4FD0(int a1, int *a2)
{
  int v2; // r0
  int v3; // r12
  unsigned int v4; // r1
  unsigned int v5; // r0
  int v6; // r1

  v2 = *a2;
  v3 = a2[2];
  v4 = a2[1] - (((unsigned int)a2[1] >> 1) & 0x55555555);
  v5 = ((16843009
       * (((v4 & 0x33333333) + ((v4 >> 2) & 0x33333333) + (((v4 & 0x33333333) + ((v4 >> 2) & 0x33333333)) >> 4)) & 0xF0F0F0F)) >> 24)
     * (((int)off_11038 * v2 / (unsigned int)off_11034 + 15) & 0xFFFFFFF0);
  switch ( v3 )
  {
    case 1:
      goto LABEL_4;
    case 2:
      v6 = 1;
      break;
    case 3:
    case 4:
    case 5:
      v6 = 4;
      break;
    case 6:
      v6 = 3;
      break;
    default:
      if ( v3 == 218103808 )
LABEL_4:
        v6 = 2;
      else
        v6 = 0;
      break;
  }
  return v5 * v6;
}
// 11034: using guessed type void *off_11034;
// 11038: using guessed type Elf32_Sym *off_11038;

//----- (00005068) --------------------------------------------------------
int __fastcall adev_open_output_stream(audio_device *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  int result; // r0
  unsigned int v8; // r10
  stream_out *v9; // r0
  stream_out *v10; // r4
  void *v11; // r3
  void *v12; // r5
  void *v13; // r6
  audio_format_t v14; // r7
  void *v15; // r3
  void *v16; // r5
  void *v17; // r6
  void *v18; // r7
  unsigned int v19; // r6
  int v20; // r0
  bool v21; // zf
  int v22; // r7
  unsigned int v23; // r0
  unsigned int v24; // r0
  unsigned int v25; // r0
  unsigned int v26; // r0

  if ( a1->output_stream_state )
  {
    _android_log_print(
      6,
      "audio_hw_primary",
      "%s(): output stream has been opened, abort...",
      "adev_open_output_stream");
    *a6 = 0;
    return -22;
  }
  v8 = 1;
  v9 = (stream_out *)calloc(1u, 0xD8u);
  v10 = v9;
  if ( !v9 )
    return -12;
  v9->channel_mask = 3;
  v9->v_172 = &dword_0 + 3;
  v11 = off_1100C;
  v12 = off_11010;
  v13 = (void *)unk_11014;
  v14 = unk_11018;
  v9->v_116 = (void *)pcm_config;
  v9->sample_rate = (int)v11;
  v9->v_124 = v12;
  v9->v_128 = v13;
  v9->format = v14;
  v15 = (void *)unk_11020;
  v16 = (void *)unk_11024;
  v17 = (void *)unk_11028;
  v18 = (void *)unk_1102C;
  v9->v_136 = (void *)unk_1101C;
  v9->v_140 = v15;
  v9->v_144 = v16;
  v9->v_148 = v17;
  v9->v_152 = v18;
  v9->stream.common.get_sample_rate = (uint32_t (__fastcall *)(const struct audio_stream *))sub_6E08;
  v9->stream.common.set_sample_rate = (int (__fastcall *)(struct audio_stream *, uint32_t))sub_6E0E;
  v9->stream.common.get_buffer_size = (size_t (__fastcall *)(const struct audio_stream *))sub_6E16;
  v9->stream.common.get_channels = (audio_channel_mask_t (__fastcall *)(const struct audio_stream *))sub_6E22;
  v9->stream.common.get_format = (audio_format_t (__fastcall *)(const struct audio_stream *))sub_6E28;
  v9->stream.common.set_format = (int (__fastcall *)(struct audio_stream *, audio_format_t))sub_6E2E;
  v9->stream.common.standby = (int (__fastcall *)(struct audio_stream *))sub_6644;
  v9->stream.common.dump = (int (__fastcall *)(const struct audio_stream *, int))sub_6E34;
  v9->stream.common.set_parameters = (int (__fastcall *)(struct audio_stream *, const char *))sub_6E38;
  v9->stream.common.get_parameters = (char *(__fastcall *)(const struct audio_stream *, const char *))sub_723C;
  v9->stream.common.add_audio_effect = (int (__fastcall *)(const struct audio_stream *, effect_handle_t))sub_7320;
  v9->stream.common.remove_audio_effect = (int (__fastcall *)(const struct audio_stream *, effect_handle_t))sub_7324;
  v9->stream.get_latency = (uint32_t (__fastcall *)(const struct audio_stream_out *))sub_7328;
  v9->stream.set_volume = (int (__fastcall *)(struct audio_stream_out *, float, float))sub_733E;
  v9->stream.write = (ssize_t (__fastcall *)(struct audio_stream_out *, const void *, size_t))sub_7344;
  v9->stream.get_render_position = (int (__fastcall *)(const struct audio_stream_out *, uint32_t *))sub_7C90;
  v9->stream.get_next_write_timestamp = (int (__fastcall *)(const struct audio_stream_out *, int64_t *))sub_7C96;
  v9->stream.get_presentation_position = (int (__fastcall *)(const struct audio_stream_out *, uint64_t *, struct timespec *))sub_7C9C;
  v9->adev = a1;
  v9->in_sample_rate = 48000;
  v9->in_format = AUDIO_FORMAT_PCM_16_BIT;
  v19 = sub_7D2C(v9);
  v10->v_192 = (void *)v19;
  v20 = v10->stream.common.get_format(&v10->stream.common);
  v21 = (v20 & 0xFF000000) == 218103808;
  if ( (v20 & 0xFF000000) != 218103808 )
    v21 = (v20 & 0xFF000000) == 0;
  if ( v21 )
  {
    switch ( v20 )
    {
      case 1:
        goto LABEL_12;
      case 2:
        v22 = 1;
        break;
      case 3:
      case 4:
      case 5:
        v22 = 4;
        break;
      case 6:
        v22 = 3;
        break;
      default:
        if ( v20 == 218103808 )
LABEL_12:
          v22 = 2;
        else
          v22 = 0;
        break;
    }
    v23 = v10->stream.common.get_channels(&v10->stream.common);
    if ( v23 >> 30 == 2 )
    {
      v24 = v23 & 0x3FFFFFFF;
    }
    else
    {
      if ( v23 >> 30 )
      {
        v26 = 0;
        goto LABEL_22;
      }
      v24 = v23 & 0x3FFFF;
    }
    v25 = ((v24 - ((v24 >> 1) & 0x55555555)) & 0x33333333) + (((v24 - ((v24 >> 1) & 0x55555555)) >> 2) & 0x33333333);
    v26 = (16843009 * ((v25 + (v25 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_22:
    v8 = v26 * v22;
  }
  v10->v_124 = (void *)(v19 / v8);
  a5[2] = v10->in_format;
  a5[1] = v10->channel_mask;
  *a5 = v10->in_sample_rate;
  LOBYTE(v10->v_160) = 1;
  pthread_mutex_lock(&a1->lock);
  if ( a1->stream_out )
  {
    pthread_mutex_unlock(&a1->lock);
    _android_log_print(6, "audio_hw_primary", "%s(): output device busy, abort...", "adev_open_output_stream");
    free(v10);
    *a6 = 0;
    return -16;
  }
  else
  {
    a1->stream_out = (struct audio_stream_out **)v10;
    a1->output_stream_state = 1;
    pthread_mutex_unlock(&a1->lock);
    result = 0;
    *a6 = v10;
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 6644: using guessed type int sub_6644();
// 6E08: using guessed type int sub_6E08();
// 6E0E: using guessed type int sub_6E0E();
// 6E16: using guessed type int sub_6E16();
// 6E22: using guessed type int sub_6E22();
// 6E28: using guessed type int sub_6E28();
// 6E2E: using guessed type int sub_6E2E();
// 6E34: using guessed type int sub_6E34();
// 6E38: using guessed type int sub_6E38();
// 723C: using guessed type int sub_723C();
// 7320: using guessed type int sub_7320();
// 7324: using guessed type int sub_7324();
// 7328: using guessed type int sub_7328();
// 733E: using guessed type int sub_733E();
// 7344: using guessed type int sub_7344();
// 7C90: using guessed type int sub_7C90();
// 7C96: using guessed type int sub_7C96();
// 7C9C: using guessed type int sub_7C9C();
// 7D2C: using guessed type int __fastcall sub_7D2C(_DWORD);
// 1100C: using guessed type void *off_1100C;
// 11010: using guessed type void *off_11010;

//----- (000052B8) --------------------------------------------------------
int __fastcall sub_52B8(audio_device *a1, stream_out *a2)
{
  sub_6644(a2);
  pthread_mutex_lock(&a1->lock);
  if ( (stream_out *)a1->stream_out == a2 )
    a1->stream_out = 0;
  a1->output_stream_state = 0;
  pthread_mutex_unlock(&a1->lock);
  return j_free(a2);
}
// 6644: using guessed type int __fastcall sub_6644(_DWORD);
// B610: using guessed type int __fastcall j_free(_DWORD);

//----- (000052F4) --------------------------------------------------------
int __fastcall sub_52F4(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v8; // r7
  int v9; // r0
  void *v10; // r6
  int v11; // r1
  Elf32_Sym *v12; // r0
  int result; // r0
  char v14[128]; // [sp+0h] [bp-A8h] BYREF

  _android_log_print(3, "audio_hw_primary", "%s():...", "adev_open_input_stream");
  *a5 = 0;
  if ( a4[1] != 16 )
  {
    a4[1] = 16;
    return -22;
  }
  v8 = calloc(1u, 0xB0u);
  if ( v8 )
  {
    property_get("persist.sys.audience.ustrhal", v14, "0");
    property_set("persist.sys.audience.ustrhal", "0");
    v9 = strncmp(v14, "1", 2u);
    if ( (a3 & 4) == 0 || v9 )
    {
      _android_log_print(3, "audio_hw_primary", "audio audience cvq disable");
      v12 = &stru_400;
      v11 = 2;
      goto LABEL_9;
    }
    _android_log_print(3, "audio_hw_primary", "audio audience cvq enabled");
    v8[18] = 1;
    v10 = malloc(0x4E264u);
    if ( v10 )
    {
      _android_log_print(3, "audio_hw_primary", "audio audience cvq enabled");
      v8[17] = v10;
      j_cvq_init((int)v10);
      v8[24] = 160000;
      v8[23] = malloc(0x27100u);
      v8[25] = 0;
      v8[26] = 0;
      v11 = 1;
      v8[27] = 0;
      v8[19] = 0;
      v8[21] = 0;
      v8[22] = 0;
      v12 = &stru_800;
LABEL_9:
      pcm_config_in = v11;
      off_11038 = v12;
      *v8 = sub_7DAC;
      v8[1] = sub_7DB2;
      v8[2] = sub_7DB8;
      v8[3] = sub_7DE0;
      v8[4] = sub_7DE4;
      v8[5] = sub_7DE8;
      v8[6] = sub_6676;
      v8[7] = sub_7DEE;
      v8[10] = sub_7DF4;
      v8[11] = sub_7F78;
      v8[12] = sub_7F84;
      v8[13] = sub_7F88;
      v8[14] = sub_7F8C;
      v8[15] = sub_7F90;
      v8[16] = sub_8A54;
      v8[43] = a1;
      *((_BYTE *)v8 + 124) = 1;
      v8[32] = *a4;
      result = 0;
      v8[39] = 0;
      v8[40] = a3;
      *a5 = v8;
      return result;
    }
    _android_log_print(6, "audio_hw_primary", "audio cvq Error audio in assigning mcvqstream");
    free(v8);
    *a5 = 0;
  }
  return -12;
}
// 400: using guessed type Elf32_Sym stru_400;
// 800: using guessed type Elf32_Sym stru_800;
// 2F6C: using guessed type int __fastcall property_get(_DWORD, _DWORD, _DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 30BC: using guessed type int __fastcall property_set(_DWORD, _DWORD);
// 7DB8: using guessed type int sub_7DB8();
// 7DF4: using guessed type int sub_7DF4();
// 7F78: using guessed type int sub_7F78();
// 7F90: using guessed type int sub_7F90();
// 11030: using guessed type int pcm_config_in;
// 11038: using guessed type Elf32_Sym *off_11038;

//----- (00005520) --------------------------------------------------------
void __fastcall sub_5520(int a1, stream_in *a2)
{
  struct audio_device *adev; // r6
  struct audio_stream_out **stream_out; // r5

  adev = a2->adev;
  stream_out = adev->stream_out;
  sub_6676(a2);
  _android_log_print(2, "audio_hw_primary", "%s(): is_cvq=%d", "adev_close_input_stream", a2->lock.__private[0]);
  if ( stream_out
    && !adev->b_289
    && (stream_out[46] != off_11034 || stream_out[47] != (struct audio_stream_out *)((char *)&dword_0 + 1))
    && (!adev->asr_ready || a2->lock.__private[0])
    && adev->amode != AUDIO_MODE_IN_CALL )
  {
    sub_6644((stream_out *)stream_out);
  }
  j_free(a2);
}
// 0: using guessed type int dword_0;
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 11034: using guessed type void *off_11034;

//----- (000055A0) --------------------------------------------------------
int sub_55A0()
{
  return 0;
}
// 55A0: using guessed type int sub_55A0();

//----- (000055A4) --------------------------------------------------------
int __fastcall sub_55A4(int a1, int a2, int a3)
{
  int v5; // r6

  if ( (*(_BYTE *)(a1 + 172) & 2) == 0 )
  {
    v5 = a3 + 2;
    sub_4364(*(_DWORD *)(a1 + 192), (int)off_10BDC[a2], a3 + 2);
    sub_4364(*(_DWORD *)(a1 + 192), (int)off_10BF0[a2], v5);
  }
  return 0;
}
// 10BDC: using guessed type char *off_10BDC[10];
// 10BF0: using guessed type char *off_10BF0[5];

//----- (000055E8) --------------------------------------------------------
int __fastcall set_voice_volume(audio_device *a1)
{
  audio_devices_t out_device; // r0
  void *v_71; // r5
  int result; // r0
  int v5; // r0

  out_device = a1->out_device;
  if ( (out_device & 0xC) != 0 )
  {
    set_headphone_volume(a1);
LABEL_3:
    v_71 = byte_9 + 6;
    goto LABEL_8;
  }
  if ( (out_device & 1) != 0 )
  {
    v_71 = a1->v_71;
  }
  else
  {
    if ( (out_device & 0x70) != 0 )
      goto LABEL_3;
    v_71 = a1->v_70;
  }
LABEL_8:
  if ( a1->messagerecord_state )
  {
    _android_log_print(2, "audio_hw_primary", "%s(): auto answer, fixed modem volume at 0dB", "set_voice_volume");
    v_71 = byte_9 + 6;
  }
  _android_log_print(
    3,
    "audio_hw_primary",
    "%s(): out_device=0x%02x, voice_volome_level=%d",
    "set_voice_volume",
    a1->out_device,
    v_71);
  result = SetAudioVolume(v_71);
  if ( result )
  {
    Open();
    v5 = SetAudioVolume(v_71);
    return _android_log_print(
             3,
             "audio_hw_primary",
             "%s(): failed to set cp volume, retry again, ret=%d",
             "set_voice_volume",
             v5);
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 31B8: using guessed type int Open(void);
// 3254: using guessed type int __fastcall SetAudioVolume(_DWORD);
// 42F0: using guessed type int __fastcall sub_42F0(_DWORD);

//----- (0000569C) --------------------------------------------------------
int __fastcall sub_569C(int a1)
{
  pthread_mutex_t *v2; // r5
  int v3; // r5
  int result; // r0
  int v5; // r5

  v2 = *(pthread_mutex_t **)(a1 + 252);
  if ( v2 )
  {
    pthread_mutex_lock(v2 + 29);
    sub_605C((int)v2);
    pthread_mutex_unlock(v2 + 29);
  }
  v3 = *(_DWORD *)(a1 + 256);
  if ( v3 && !*(_BYTE *)(v3 + 160) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 100));
    if ( *(_BYTE *)(a1 + 260) && (*(_BYTE *)(a1 + 172) & 2) != 0 )
    {
      sub_6164(a1);
      *(_BYTE *)(a1 + 260) = 0;
    }
    sub_61B8((stream_out *)v3);
    sub_629C(a1);
    return j_pthread_mutex_unlock((pthread_mutex_t *)(v3 + 100));
  }
  else if ( *(_DWORD *)(a1 + 228) || (result = *(_DWORD *)(a1 + 232)) != 0 )
  {
    v5 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)(a1 + 172) = 0;
    sub_5730((audio_device *)a1);
    *(_DWORD *)(a1 + 172) = v5;
    return sub_629C(a1);
  }
  return result;
}

//----- (00005730) --------------------------------------------------------
int __fastcall sub_5730(audio_device *a1)
{
  int output_device_id; // r8
  int input_source_id; // r10
  audio_devices_t out_device; // r5
  int v5; // r11
  int v6; // r0
  __int64 v7; // r0
  int v8; // r9
  __int64 v9; // kr00_8
  audio_mode_t amode; // r2
  void *v11; // r7
  void **v12; // r1
  void **v13; // r1
  _DWORD *v14; // r0
  bool v15; // zf
  struct pcm *pcm_be_out; // r0
  struct pcm *pcm_be_in; // r0
  struct pcm *v18; // r0
  struct pcm *v19; // r0
  const char *error; // r0
  const char *v21; // r0
  struct pcm *v22; // r0
  struct pcm *v23; // r0
  struct audio_stream_out **v24; // r12
  unsigned __int32 v25; // r0
  bool v26; // zf
  struct pcm *pcm_pa_out; // r7
  struct pcm *v28; // r0
  int v29; // r0
  struct pcm *pcm_pa_in; // r7
  struct pcm *v31; // r0
  int is_ready; // r0
  struct pcm *pcm_btsco_out; // r0
  struct pcm *v34; // r7
  struct pcm *v35; // r0
  int v36; // r0
  struct pcm *pcm_btsco_in; // r7
  struct pcm *v38; // r0
  int v39; // r0
  struct pcm *v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  char *v43; // r5
  char *v44; // r7
  int asr_ready; // r0
  audio_devices_t in_device; // r0
  int v47; // r1
  const char *v48; // r0
  const char *v49; // r3
  audio_mode_t v50; // r5
  const char *v52; // r0
  const char *v53; // r0
  struct pcm *v54; // r0
  struct pcm *v55; // r0
  struct audio_stream_out **stream_out; // [sp+10h] [bp-B0h]
  int v57; // [sp+14h] [bp-ACh]
  char s1[128]; // [sp+18h] [bp-A8h] BYREF
  int v59; // [sp+98h] [bp-28h]

  output_device_id = j_get_output_device_id(a1, a1->out_device);
  input_source_id = j_get_input_source_id(a1, a1->v_50);
  out_device = a1->out_device;
  stream_out = a1->stream_out;
  if ( (out_device & 0x70) != 0 )
    v5 = 1;
  else
    v5 = (unsigned __int8)(a1->in_device & 8) >> 3;
  if ( a1->amode == AUDIO_MODE_IN_CALL )
  {
    memset(s1, 0, sizeof(s1));
    if ( property_get("hw.messagerecord.state", s1, "0") <= -1 )
    {
      _android_log_print(6, "audio_hw_primary", "%s(): cann't get hw.messagerecord.state", "set_voice_autoanswer");
      HIDWORD(v7) = a1->amode;
    }
    else
    {
      v6 = strcmp(s1, "1");
      a1->messagerecord_state = v6 == 0;
      HIDWORD(v7) = a1->amode;
      LODWORD(v7) = v6 != 0;
      if ( v7 == 0x200000000LL )
      {
        j_audio_route_reset(a1->audio_route);
        j_audio_route_apply_path((int)a1->audio_route, "voice-call-auto-answer-capture");
        j_audio_route_update_mixer(a1->audio_route);
        return _stack_chk_guard - v59;
      }
    }
    if ( HIDWORD(v7) == 2 )
      set_voice_volume(a1);
  }
  v8 = out_device & 2;
  if ( a1->b_289 )
  {
    v57 = out_device & 0xC;
    sub_62E0(a1);
    sub_427C(a1);
  }
  else
  {
    v57 = out_device & 0xC;
    if ( (out_device & 0xC) != 0 )
      set_headphone_volume(a1);
  }
  if ( (out_device & 2) == 0 && a1->tfa_power_state )
  {
    sub_6164(a1);
    a1->tfa_power_state = 0;
  }
  if ( output_device_id == 8 && input_source_id == 11 )
    sub_629C(a1);
  if ( input_source_id == 11 && (output_device_id == 8 || a1->b_289) )
    goto LABEL_68;
  v9 = *(_QWORD *)&a1->v_63;
  *(_DWORD *)s1 = pcm_config_backend;
  *(_DWORD *)&s1[4] = unk_11084;
  *(_DWORD *)&s1[8] = unk_11088;
  *(_DWORD *)&s1[12] = unk_1108C;
  *(_DWORD *)&s1[16] = unk_11090;
  *(_DWORD *)&s1[20] = unk_11094;
  *(_DWORD *)&s1[24] = unk_11098;
  *(_DWORD *)&s1[28] = unk_1109C;
  *(_DWORD *)&s1[32] = unk_110A0;
  *(_DWORD *)&s1[36] = unk_110A4;
  amode = a1->amode;
  if ( amode == AUDIO_MODE_IN_COMMUNICATION )
  {
    v12 = (void **)(HIDWORD(v9) + 120);
    if ( !HIDWORD(v9) )
      v12 = &off_1100C;
    v11 = *v12;
    *(_DWORD *)&s1[4] = *v12;
LABEL_44:
    v15 = (_DWORD)v9 == 0;
    if ( !(_DWORD)v9 )
      v15 = HIDWORD(v9) == 0;
    if ( v15 && !a1->pcm_voice_out )
      goto LABEL_68;
    goto LABEL_49;
  }
  if ( amode == AUDIO_MODE_IN_CALL )
  {
    v11 = (void *)dword_1105C;
    *(_DWORD *)&s1[4] = dword_1105C;
    goto LABEL_44;
  }
  if ( !(_DWORD)v9 )
  {
    v13 = &off_1100C;
    v14 = &unk_11018;
    if ( HIDWORD(v9) )
      v13 = (void **)(HIDWORD(v9) + 120);
    v11 = *v13;
    *(_DWORD *)&s1[4] = *v13;
    if ( HIDWORD(v9) )
      v14 = (_DWORD *)(HIDWORD(v9) + 132);
    *(_DWORD *)&s1[16] = *v14;
    goto LABEL_44;
  }
  if ( *(_DWORD *)(v9 + 156) == 6 && *(_DWORD *)(v9 + 72) == 1 )
    v11 = "%s(): voice_call_wb=%d, bluetooth_nrec=%d" + 24;
  else
    v11 = off_11034;
  *(_DWORD *)&s1[4] = v11;
  if ( !a1->asr_ready )
  {
    if ( a1->tfa_power_state )
    {
      NxpTfa98xx_SetMute(2);
      a1->mute_state = 1;
    }
    sub_4364(a1->mixer, "HPOUT Digital Switch", 0);
    sub_4364(a1->mixer, "EPOUT Digital Switch", 0);
    sub_4364(a1->mixer, "AIF2TX1 Input 1", 0);
    sub_4364(a1->mixer, "AIF2TX2 Input 1", 0);
    a1->b_268 = 1;
  }
LABEL_49:
  if ( !a1->pcm_be_out
    || !a1->pcm_be_in
    || byte_116D4 != 1
    || v11 != (void *)dword_116D8
    || *(_DWORD *)&s1[16] != dword_116DC )
  {
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): open %s-dai, rate=%d, format=%d,channels=%d",
      "start_backend",
      "media",
      v11,
      *(_DWORD *)&s1[16],
      *(_DWORD *)s1);
    pcm_be_out = a1->pcm_be_out;
    if ( pcm_be_out )
    {
      pcm_close(pcm_be_out);
      a1->pcm_be_out = 0;
    }
    pcm_be_in = a1->pcm_be_in;
    if ( pcm_be_in )
    {
      pcm_close(pcm_be_in);
      a1->pcm_be_in = 0;
    }
    v18 = (struct pcm *)pcm_open(0, 2, 0, s1);
    a1->pcm_be_out = v18;
    if ( v18 && !pcm_is_ready() )
    {
      error = (const char *)pcm_get_error(a1->pcm_be_out);
      _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(BACKEND_OUT) failed: %s", "start_backend", error);
    }
    else
    {
      v19 = (struct pcm *)pcm_open(0, 2, 0x10000000, s1);
      a1->pcm_be_in = v19;
      if ( !v19 || pcm_is_ready() )
      {
        pcm_prepare(a1->pcm_be_out);
        pcm_prepare(a1->pcm_be_in);
        byte_116D4 = 1;
        dword_116D8 = *(_DWORD *)&s1[4];
        dword_116DC = *(_DWORD *)&s1[16];
        goto LABEL_68;
      }
      v21 = (const char *)pcm_get_error(a1->pcm_be_in);
      _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(BACKEND_IN) failed: %s", "start_backend", v21);
      v22 = a1->pcm_be_in;
      if ( v22 )
      {
        pcm_close(v22);
        a1->pcm_be_in = 0;
      }
    }
    v23 = a1->pcm_be_out;
    if ( v23 )
    {
      pcm_close(v23);
      a1->pcm_be_out = 0;
    }
  }
LABEL_68:
  if ( (out_device & 2) == 0 || a1->tfa_power_state )
    goto LABEL_85;
  v24 = a1->stream_out;
  *(_DWORD *)s1 = pcm_config_amplifier;
  *(_DWORD *)&s1[4] = off_110D4;
  *(_DWORD *)&s1[8] = off_110D8;
  *(_DWORD *)&s1[12] = unk_110DC;
  *(_DWORD *)&s1[16] = unk_110E0;
  *(_DWORD *)&s1[20] = unk_110E4;
  *(_DWORD *)&s1[24] = unk_110E8;
  *(_DWORD *)&s1[28] = unk_110EC;
  *(_DWORD *)&s1[32] = unk_110F0;
  *(_DWORD *)&s1[36] = unk_110F4;
  v25 = a1->amode & 0xFFFFFFFE;
  if ( v25 == 2 )
    goto LABEL_75;
  v26 = v24 == 0;
  if ( v24 )
  {
    v25 = (unsigned __int32)v24[30];
    v26 = v25 == 0;
  }
  if ( !v26 )
  {
    if ( v25 % 0xAC44 )
    {
LABEL_75:
      *(_DWORD *)&s1[4] = 48000;
      goto LABEL_76;
    }
    *(_DWORD *)&s1[4] = 44100;
  }
LABEL_76:
  if ( a1->pcm_pa_out )
  {
LABEL_80:
    if ( a1->pcm_pa_in )
    {
LABEL_84:
      a1->sample_rate = *(_DWORD *)&s1[4];
      goto LABEL_85;
    }
    pcm_pa_in = 0;
    v31 = (struct pcm *)pcm_open(0, 6, 0x10000000, s1);
    a1->pcm_pa_in = v31;
    if ( !v31 || (is_ready = pcm_is_ready(), pcm_pa_in = a1->pcm_pa_in, is_ready) )
    {
      pcm_prepare(pcm_pa_in);
      goto LABEL_84;
    }
    v53 = (const char *)pcm_get_error(a1->pcm_pa_in);
    _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(PA_IN) failed: %s", "pre_start_amplifier", v53);
    v54 = a1->pcm_pa_in;
    if ( v54 )
    {
      pcm_close(v54);
      a1->pcm_pa_in = 0;
    }
    goto LABEL_146;
  }
  pcm_pa_out = 0;
  v28 = (struct pcm *)pcm_open(0, 6, 0, s1);
  a1->pcm_pa_out = v28;
  if ( !v28 || (v29 = pcm_is_ready(), pcm_pa_out = a1->pcm_pa_out, v29) )
  {
    pcm_prepare(pcm_pa_out);
    goto LABEL_80;
  }
  v52 = (const char *)pcm_get_error(a1->pcm_pa_out);
  _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(PA_OUT) failed: %s", "pre_start_amplifier", v52);
LABEL_146:
  v55 = a1->pcm_pa_out;
  if ( v55 )
  {
    pcm_close(v55);
    a1->pcm_pa_out = 0;
  }
LABEL_85:
  pcm_btsco_out = a1->pcm_btsco_out;
  if ( v5 == 1 )
  {
    if ( !pcm_btsco_out )
    {
      _android_log_print(3, "audio_hw_primary", "%s():...", "start_bt_sco");
      v34 = 0;
      v35 = (struct pcm *)pcm_open(0, 5, 0, &pcm_config_sco);
      a1->pcm_btsco_out = v35;
      if ( v35 )
      {
        v36 = pcm_is_ready();
        v34 = a1->pcm_btsco_out;
        if ( !v36 )
        {
          v41 = (const char *)pcm_get_error(a1->pcm_btsco_out);
          _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(SCO_OUT) failed: %s", "start_bt_sco", v41);
LABEL_100:
          pcm_close(a1->pcm_btsco_out);
          a1->pcm_btsco_out = 0;
          goto LABEL_101;
        }
      }
      pcm_prepare(v34);
    }
    if ( a1->pcm_btsco_in )
      goto LABEL_101;
    pcm_btsco_in = 0;
    v38 = (struct pcm *)pcm_open(0, 5, 0x10000000, &pcm_config_sco);
    a1->pcm_btsco_in = v38;
    if ( !v38 || (v39 = pcm_is_ready(), pcm_btsco_in = a1->pcm_btsco_in, v39) )
    {
      pcm_prepare(pcm_btsco_in);
      goto LABEL_101;
    }
    v42 = (const char *)pcm_get_error(a1->pcm_btsco_in);
    _android_log_print(6, "audio_hw_primary", "%s(): pcm_open(SCO_IN) failed: %s", "start_bt_sco", v42);
    pcm_close(a1->pcm_btsco_in);
    a1->pcm_btsco_in = 0;
    goto LABEL_100;
  }
  if ( pcm_btsco_out )
  {
    _android_log_print(3, "audio_hw_primary", "%s():...", "stop_bt_sco");
    pcm_stop(a1->pcm_btsco_out);
    pcm_close(a1->pcm_btsco_out);
    a1->pcm_btsco_out = 0;
  }
  v40 = a1->pcm_btsco_in;
  if ( v40 )
  {
    pcm_stop(v40);
    pcm_close(a1->pcm_btsco_in);
    a1->pcm_btsco_in = 0;
  }
LABEL_101:
  j_audio_route_reset(a1->audio_route);
  j_audio_route_apply_path((int)a1->audio_route, "dummy");
  if ( input_source_id == 11 )
  {
    if ( output_device_id == 8 )
    {
      v43 = 0;
      v44 = 0;
    }
    else
    {
      if ( a1->amode == AUDIO_MODE_IN_CALL )
      {
        asr_ready = 0;
      }
      else
      {
        asr_ready = a1->asr_ready;
        if ( a1->asr_ready )
          asr_ready = 2;
      }
      v43 = 0;
      v44 = *(char **)(&off_10AC4[7 * asr_ready])[output_device_id];
    }
  }
  else if ( output_device_id == 8 )
  {
    in_device = a1->in_device;
    v47 = 0;
    if ( in_device == -2147483640 )
      v47 = 3;
    if ( in_device == -2147483632 )
      v47 = 1;
    v44 = 0;
    v43 = (char *)*((_DWORD *)(&off_10AC4[7 * input_source_id])[v47] + 1);
  }
  else
  {
    v43 = (char *)*((_DWORD *)(&off_10AC4[7 * input_source_id])[output_device_id] + 1);
    v44 = *(char **)(&off_10AC4[7 * input_source_id])[output_device_id];
  }
  v48 = "none";
  v49 = "none";
  if ( v43 )
    v49 = v43;
  if ( v44 )
    v48 = v44;
  _android_log_print(
    3,
    "audio_hw_primary",
    "%s(): devices %#x input src %d output route %s input route %s",
    "select_devices",
    a1->out_device,
    a1->v_50,
    v48,
    v49);
  if ( v44 )
    j_audio_route_apply_path((int)a1->audio_route, v44);
  if ( v43 )
    j_audio_route_apply_path((int)a1->audio_route, v43);
  _android_log_print(3, "audio_hw_primary", "%s(): route time measurement: start", "select_devices");
  j_audio_route_update_mixer(a1->audio_route);
  _android_log_print(3, "audio_hw_primary", "%s(): route time measurement: end", "select_devices");
  if ( v57 && a1->amode == AUDIO_MODE_NORMAL && !a1->b_289 )
    usleep(0x4E20u);
  if ( !v8 )
  {
    if ( !a1->tfa_power_state )
      goto LABEL_139;
LABEL_136:
    if ( a1->mute_state && !a1->asr_ready )
    {
      NxpTfa98xx_SetMute(0);
      a1->mute_state = 0;
    }
    goto LABEL_139;
  }
  if ( a1->tfa_power_state )
    goto LABEL_136;
  v50 = a1->amode;
  if ( stream_out || v50 == AUDIO_MODE_IN_CALL )
  {
    usleep(0x1388u);
    if ( NxpTfa98xx_PowerOn(stream_out == 0 || v50 == AUDIO_MODE_IN_CALL, a1->sample_rate, 0) )
      _android_log_print(6, "audio_hw_primary", "%s(): failed to power on tfa98xx", "start_amplifier");
    a1->tfa_power_state = 1;
    goto LABEL_136;
  }
LABEL_139:
  if ( a1->b_268 )
  {
    sub_4364(a1->mixer, "HPOUT Digital Switch", 1);
    sub_4364(a1->mixer, "EPOUT Digital Switch", 1);
    sub_4364(a1->mixer, "AIF2TX1 Input 1", 38);
    sub_4364(a1->mixer, "AIF2TX2 Input 1", 39);
    a1->b_268 = 0;
  }
  return _stack_chk_guard - v59;
}
// 2F6C: using guessed type int __fastcall property_get(_DWORD, _DWORD, _DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int pcm_is_ready(void);
// 3068: using guessed type int __fastcall pcm_prepare(_DWORD);
// 3074: using guessed type int __fastcall j_audio_route_reset(_DWORD);
// 308C: using guessed type int __fastcall j_audio_route_update_mixer(_DWORD);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 31DC: using guessed type int __fastcall pcm_stop(_DWORD);
// 3260: using guessed type int __fastcall j_get_output_device_id(_DWORD, _DWORD);
// 326C: using guessed type int __fastcall j_get_input_source_id(_DWORD, _DWORD);
// 3284: using guessed type int __fastcall NxpTfa98xx_SetMute(_DWORD);
// 3290: using guessed type int __fastcall NxpTfa98xx_PowerOn(_DWORD, _DWORD, _DWORD);
// 427C: using guessed type int __fastcall sub_427C(_DWORD);
// 4364: using guessed type int __fastcall sub_4364(_DWORD, _DWORD, _DWORD);
// 6164: using guessed type int __fastcall sub_6164(_DWORD);
// 629C: using guessed type int __fastcall sub_629C(_DWORD);
// 62E0: using guessed type int __fastcall sub_62E0(_DWORD);
// 10AC4: using guessed type char *off_10AC4[80];
// 1100C: using guessed type void *off_1100C;
// 11034: using guessed type void *off_11034;
// 1105C: using guessed type int dword_1105C;
// 110D4: using guessed type void *off_110D4;
// 110D8: using guessed type Elf32_Sym *off_110D8;
// 116D4: using guessed type char byte_116D4;
// 116D8: using guessed type int dword_116D8;
// 116DC: using guessed type int dword_116DC;

//----- (0000605C) --------------------------------------------------------
void __fastcall sub_605C(int a1)
{
  int v2; // r5
  int v3; // r6
  int v4; // r1
  int v5; // r0
  int v6; // r1
  int v7; // r0

  v2 = *(_DWORD *)(a1 + 68);
  v3 = *(_DWORD *)(a1 + 172);
  _android_log_print(3, "audio_hw_primary", "%s():...", "do_in_standby");
  if ( !*(_BYTE *)(a1 + 124) )
  {
    v4 = *(_DWORD *)(v3 + 168);
    if ( v4 == 2 )
    {
      v5 = *(_DWORD *)(a1 + 172);
      v6 = 4;
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 172);
      if ( v4 == 3 )
        v6 = 7;
      else
        v6 = 0;
    }
    *(_DWORD *)(v5 + 200) = v6;
    if ( (*(_DWORD *)(v3 + 168) & 0xFFFFFFFE) != 2 )
      *(_DWORD *)(*(_DWORD *)(a1 + 172) + 176) = 0;
    _android_log_print(
      2,
      "audio_hw_primary",
      "%s(): asr_ready=%d, is_cvq=%d",
      "do_in_standby",
      *(unsigned __int8 *)(v3 + 313),
      *(_DWORD *)(a1 + 72));
    v7 = *(_DWORD *)(a1 + 72);
    if ( !v7 )
    {
      sub_5730(*(audio_device **)(a1 + 172));
      v7 = *(_DWORD *)(a1 + 72);
    }
    if ( v7 == 1 )
    {
      if ( !*(_DWORD *)(v2 + 320072) )
        (*(void (__fastcall **)(int))(v2 + 320080))(v2);
      *(_DWORD *)(a1 + 76) = 1;
      pthread_join(*(_DWORD *)(a1 + 80), 0);
      free(*(void **)(a1 + 68));
      free(*(void **)(a1 + 92));
    }
    pcm_close(*(_DWORD *)(a1 + 120));
    *(_DWORD *)(a1 + 120) = 0;
    *(_BYTE *)(a1 + 124) = 1;
    *(_DWORD *)(v3 + 252) = 0;
    if ( *(_DWORD *)(a1 + 132) )
    {
      release_resampler();
      *(_DWORD *)(a1 + 132) = 0;
    }
    j_free(*(void **)(a1 + 144));
  }
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 32A8: using guessed type int release_resampler(void);

//----- (00006164) --------------------------------------------------------
int __fastcall sub_6164(int a1)
{
  int v2; // r0
  int result; // r0

  if ( NxpTfa98xx_PowerOff(a1) )
    _android_log_print(6, "audio_hw_primary", "%s(): failed to power off tfa98xx", "stop_amplifier");
  usleep(0x1388u);
  v2 = *(_DWORD *)(a1 + 244);
  if ( v2 )
  {
    pcm_close(v2);
    *(_DWORD *)(a1 + 244) = 0;
  }
  result = *(_DWORD *)(a1 + 248);
  if ( result )
  {
    pcm_close(result);
    result = 0;
    *(_DWORD *)(a1 + 248) = 0;
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 32B4: using guessed type int __fastcall NxpTfa98xx_PowerOff(_DWORD);

//----- (000061B8) --------------------------------------------------------
int __fastcall sub_61B8(stream_out *a1)
{
  struct audio_device *adev; // r8
  int result; // r0
  audio_devices_t out_device; // r6
  struct audio_stream_out **stream_out; // r1
  struct audio_stream_out *v6; // r0
  struct pcm **p_pcm; // r6
  int i; // r5
  struct pcm *v9; // r0

  adev = a1->adev;
  _android_log_print(3, "audio_hw_primary", "%s():...", "do_out_standby");
  result = LOBYTE(a1->v_160);
  if ( !LOBYTE(a1->v_160) )
  {
    if ( adev->b_289 )
    {
      adev->b_289 = 0;
      if ( adev->b_314 )
      {
        free(adev->v_79);
        adev->b_314 = 0;
      }
      adev->hifi_gain = -1;
    }
    if ( adev->amode != AUDIO_MODE_IN_CALL && !adev->asr_ready )
    {
      out_device = adev->out_device;
      stream_out = a1->adev->stream_out;
      v6 = 0;
      if ( stream_out && stream_out != (struct audio_stream_out **)a1 )
      {
        if ( *((_BYTE *)stream_out + 160) )
          v6 = 0;
        else
          v6 = stream_out[41];
      }
      adev->out_device = (audio_devices_t)v6;
      sub_5730(adev);
      adev->out_device = out_device;
    }
    p_pcm = &a1->pcm;
    for ( i = 0; i != 3; ++i )
    {
      v9 = p_pcm[i];
      if ( v9 )
      {
        pcm_stop(v9);
        pcm_close(p_pcm[i]);
        p_pcm[i] = 0;
      }
    }
    LOBYTE(a1->v_160) = 1;
    adev->stream_out = 0;
    result = (int)a1->resampler;
    if ( result )
    {
      release_resampler();
      a1->resampler = 0;
      return j_free(a1->v_200);
    }
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 31DC: using guessed type int __fastcall pcm_stop(_DWORD);
// 32A8: using guessed type int release_resampler(void);
// B610: using guessed type int __fastcall j_free(_DWORD);

//----- (0000629C) --------------------------------------------------------
int __fastcall sub_629C(int a1)
{
  int v2; // r0
  int result; // r0

  _android_log_print(3, "audio_hw_primary", "%s():...", "stop_backend");
  v2 = *(_DWORD *)(a1 + 232);
  if ( v2 )
  {
    pcm_close(v2);
    *(_DWORD *)(a1 + 232) = 0;
  }
  result = *(_DWORD *)(a1 + 228);
  if ( result )
  {
    pcm_close(result);
    result = 0;
    *(_DWORD *)(a1 + 228) = 0;
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);

//----- (000062E0) --------------------------------------------------------
int __fastcall sub_62E0(audio_device *a1)
{
  int v2; // r0
  int v3; // r6
  int chk; // r5
  int v5; // r7
  int v6; // r0
  int hifi_impedance; // r0
  int v8; // r5
  int v9; // r6
  bool v10; // cf
  int v11; // r0
  char nptr[20]; // [sp+Ch] [bp-2Ch] BYREF
  int v14; // [sp+20h] [bp-18h]

  v2 = open("/sys/class/arizona/wm8998_hp_impedance/hp_impedance", 0);
  v3 = v2;
  if ( v2 < 0 )
  {
    v6 = _android_log_print(
           6,
           "audio_hw_primary",
           "%s(): failed to open %s\n",
           "read_impedance",
           "/sys/class/arizona/wm8998_hp_impedance/hp_impedance");
    v5 = 128;
    chk = -*(_DWORD *)_errno(v6);
  }
  else
  {
    chk = _read_chk(v2, nptr, 20, 20);
    if ( chk <= -1 )
    {
      _android_log_print(
        6,
        "audio_hw_primary",
        "%s(): failed to read %s",
        "read_impedance",
        "/sys/class/arizona/wm8998_hp_impedance/hp_impedance");
      v5 = 128;
    }
    else
    {
      v5 = atoi(nptr);
    }
    close(v3);
  }
  if ( chk <= -1 )
  {
    _android_log_print(6, "audio_hw_primary", "%s : %d", "set_hifi_gain", chk);
  }
  else
  {
    a1->hifi_impedance = v5 - 35;
    _android_log_print(
      2,
      "audio_hw_primary",
      "%s(): hp_impedance=%d, gain_state=%d",
      "set_hifi_gain",
      v5 - 35,
      a1->hifi_gain_state);
    switch ( a1->hifi_gain_state )
    {
      case 0:
        hifi_impedance = a1->hifi_impedance;
        if ( (unsigned int)hifi_impedance < 8 )
          goto LABEL_27;
        if ( (unsigned int)(hifi_impedance - 8) < 5 )
          goto LABEL_32;
        v8 = 1;
        v9 = 0;
        if ( (unsigned int)(hifi_impedance - 50) >= 0xF )
        {
          v10 = (unsigned int)(hifi_impedance - 13) >= 7;
          if ( (unsigned int)(hifi_impedance - 13) >= 7 )
            v10 = (unsigned int)(hifi_impedance - 20) >= 0x1E;
          if ( v10 )
          {
            v8 = 1;
            if ( hifi_impedance > 64 )
              v8 = 2;
            v9 = 0;
          }
        }
        goto LABEL_46;
      case 1:
        hifi_impedance = a1->hifi_impedance;
        if ( (unsigned int)hifi_impedance < 8 )
          goto LABEL_27;
        v9 = 0;
        if ( (unsigned int)(hifi_impedance - 8) < 5 )
          v9 = 6;
        v8 = 1;
        goto LABEL_46;
      case 2:
        hifi_impedance = a1->hifi_impedance;
        if ( (unsigned int)hifi_impedance >= 8 )
        {
          if ( (unsigned int)(hifi_impedance - 8) >= 5 )
          {
            if ( (unsigned int)(hifi_impedance - 13) >= 7 )
            {
              if ( (unsigned int)(hifi_impedance - 20) >= 0xA )
              {
                if ( (unsigned int)(hifi_impedance - 30) >= 0xA )
                {
                  if ( (unsigned int)(hifi_impedance - 40) >= 0xA )
                  {
                    if ( (unsigned int)(hifi_impedance - 50) >= 0xA )
                    {
                      v8 = 1;
                      if ( hifi_impedance > 59 )
                        v8 = 2;
                      v9 = 0;
                    }
                    else
                    {
                      v9 = 2;
                      v8 = 2;
                    }
                  }
                  else
                  {
                    v8 = 2;
                    v9 = 4;
                  }
                }
                else
                {
                  v8 = 2;
                  v9 = 8;
                }
              }
              else
              {
                v8 = 2;
                v9 = 12;
              }
            }
            else
            {
              v8 = 1;
              v9 = 0;
            }
          }
          else
          {
LABEL_32:
            v8 = 1;
            v9 = 6;
          }
        }
        else
        {
LABEL_27:
          v8 = 1;
          v9 = 12;
        }
        goto LABEL_46;
      case 3:
        hifi_impedance = a1->hifi_impedance;
        v8 = 1;
        a1->hifi_gain = 3;
        if ( hifi_impedance > 49 )
          v8 = 2;
        v9 = 0;
LABEL_46:
        _android_log_print(
          3,
          "audio_hw_primary",
          "%s:is_oversea=%d,impedance=%d",
          "set_hifi_gain",
          a1->is_oversea,
          hifi_impedance);
        if ( a1->is_oversea )
        {
          v11 = a1->hifi_impedance;
          if ( v11 <= 120 )
            v9 = (int)(log10((double)v11) * -20.0 + 43.0);
          else
            v9 = 0;
        }
        a1->hifi_volume = v9;
        _android_log_print(
          3,
          "audio_hw_primary",
          "%s(): gain: %d >> %d,volume_compensation=%d",
          "set_hifi_gain",
          a1->hifi_gain,
          v8,
          v9);
        if ( v8 != a1->hifi_gain )
        {
          sub_4364(a1->hifi_mixer, "Filter Shape", 0);
          sub_4364(a1->hifi_mixer, "bypass IIR", 0);
          sub_4364(a1->hifi_mixer, "IIR bandwidth", 0);
          sub_4364(a1->hifi_mixer, "Gain selection", v8);
          sub_4364(a1->hifi_mixer, "THD Compensation", 1);
          sub_4364(a1->hifi_mixer, "2nd Harmonic Compensation", 0);
          sub_4364(a1->hifi_mixer, "3nd Harmonic Compensation", 254);
          sub_4364(a1->hifi_mixer, "custom FIR enable", 1);
          sub_4364(a1->hifi_mixer, "stage2 filter type", 0);
          if ( a1->hifi_gain_state != 3 )
            a1->hifi_gain = v8;
        }
        break;
      default:
        _android_log_print(6, "audio_hw_primary", "%s(): invalid gain state", "set_hifi_gain");
        break;
    }
  }
  return _stack_chk_guard - v14;
}
// 2FC0: using guessed type int __fastcall _errno(_DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 32CC: using guessed type int __fastcall _read_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 4364: using guessed type int __fastcall sub_4364(_DWORD, _DWORD, _DWORD);

//----- (00006644) --------------------------------------------------------
int __fastcall sub_6644(stream_out *a1)
{
  pthread_mutex_lock(&a1->adev->lock);
  pthread_mutex_lock(&a1->lock);
  sub_61B8(a1);
  pthread_mutex_unlock(&a1->lock);
  pthread_mutex_unlock(&a1->adev->lock);
  return 0;
}
// 61B8: using guessed type int __fastcall sub_61B8(_DWORD);

//----- (00006676) --------------------------------------------------------
int __fastcall sub_6676(stream_in *a1)
{
  pthread_mutex_lock(&a1->adev->lock);
  pthread_mutex_lock((pthread_mutex_t *)&a1->pcminfo);
  sub_605C(a1);
  pthread_mutex_unlock((pthread_mutex_t *)&a1->pcminfo);
  pthread_mutex_unlock(&a1->adev->lock);
  return 0;
}
// 605C: using guessed type int __fastcall sub_605C(_DWORD);

//----- (000066B0) --------------------------------------------------------
int __fastcall sub_66B0(audio_device *a1, int a2)
{
  int str; // r6
  int is_headphone_on; // r5
  int v5; // r6
  int v6; // r7
  char ***v7; // r0
  int v8; // r6
  int v9; // r9
  char **v10; // r8
  int v11; // r10
  struct pcm *v12; // r0
  struct pcm *v13; // r0
  struct pcm *v14; // r0
  struct pcm *v15; // r0
  struct pcm *v16; // r0
  struct pcm *v17; // r0
  const char *error; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  int v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  int v26; // r0
  pthread_t newthread; // [sp+4h] [bp-74h] BYREF
  __int64 v28[4]; // [sp+8h] [bp-70h] BYREF
  int v29; // [sp+28h] [bp-50h]
  int v30; // [sp+2Ch] [bp-4Ch]
  char s1[32]; // [sp+30h] [bp-48h] BYREF

  str = str_parms_create_str(a2);
  is_headphone_on = j_is_headphone_on();
  v5 = str_parms_get_str(str, "factory_test", s1, 32);
  if ( v5 < 0 )
    return v5;
  if ( !strcmp(s1, "earphone") )
  {
    v6 = -1;
    v7 = test_earphones_ptr;
LABEL_20:
    v10 = *v7;
    v9 = 0;
    v8 = 0;
    goto LABEL_21;
  }
  if ( !strcmp(s1, "headphone") )
  {
    v6 = -1;
    v7 = test_headphone_ptr;
    goto LABEL_20;
  }
  if ( !strcmp(s1, "speaker") )
  {
    v6 = -1;
    v8 = 0;
    v9 = 1;
    v10 = &test_speaker;
LABEL_21:
    v11 = 0;
    goto LABEL_22;
  }
  if ( !strcmp(s1, "pri_mic") )
  {
    v6 = -1;
    v7 = test_pri_mic_ptr;
    goto LABEL_20;
  }
  if ( !strcmp(s1, "sec_mic") )
  {
    v6 = -1;
    v7 = test_sec_mic_ptr;
    goto LABEL_20;
  }
  if ( !strcmp(s1, "ter_mic") )
  {
    v6 = -1;
    v7 = test_ter_mic_ptr;
    goto LABEL_20;
  }
  if ( !strcmp(s1, "hifi_high_gain") )
  {
    v6 = 2;
    v8 = 1;
    v10 = 0;
    v9 = 0;
    goto LABEL_21;
  }
  if ( !strcmp(s1, "hifi_low_gain") )
  {
    v8 = 1;
    v10 = 0;
    v9 = 0;
    v6 = 1;
    goto LABEL_21;
  }
  if ( strcmp(s1, "pa_calibration") )
  {
    if ( strcmp(s1, "modem_loopback") )
    {
      if ( !strcmp(s1, "off") )
      {
        _android_log_print(3, "audio_hw_primary", "%s(): factory test over, close all pcm streams", "audio_test");
        v26 = pthread_mutex_lock(&a1->lock);
        NxpTfa98xx_PowerOff(v26);
        sub_6CBC(a1);
        v5 = 0;
        sub_6D54(a1->mixer, &default_settings, 0);
        dword_116CC = 1;
        SetAudioLoopback(0, 0);
        pthread_mutex_unlock(&a1->lock);
      }
      else
      {
        _android_log_print(6, "audio_hw_primary", "%s(): unsupported factory test command", "audio_test");
        return -22;
      }
      return v5;
    }
    SetAudioLoopback(1, 1);
    SetAudioVolume(15);
    if ( is_headphone_on == 1 )
    {
      _android_log_print(3, "audio_hw_primary", "test modem loopback: outdevice=headphone");
      v6 = -1;
      v7 = &test_modem_loopback_headphone_ptr;
    }
    else
    {
      _android_log_print(3, "audio_hw_primary", "test modem loopback: outdevice=earphone");
      v6 = -1;
      v7 = test_modem_loopback_earphone_ptr;
    }
    goto LABEL_20;
  }
  v11 = 1;
  v6 = -1;
  v10 = 0;
  v9 = 0;
  v8 = 0;
LABEL_22:
  pthread_mutex_lock(&a1->lock);
  sub_6CBC(a1);
  sub_6D54(a1->mixer, &default_settings, 0);
  dword_116CC = 1;
  if ( v8 == 1 )
  {
    v5 = 0;
    dword_116C8 = v6;
    pthread_create(&newthread, 0, (void *(*)(void *))thread_test_hifi, a1);
    pthread_mutex_unlock(&a1->lock);
    return v5;
  }
  memset(&v28[2], 0, 16);
  v29 = 0;
  v30 = 0;
  v28[0] = 0xBB8000000002LL;
  v28[1] = 0x200000800LL;
  v12 = (struct pcm *)pcm_open(0, 2, 0, v28);
  a1->pcm_be_out = v12;
  if ( v12 && !pcm_is_ready() )
  {
    error = (const char *)pcm_get_error(a1->pcm_be_out);
    _android_log_print(6, "audio_hw_primary", "pcm_open(VOICE_BE_OUT) failed: %s", error);
LABEL_53:
    _android_log_print(6, "audio_hw_primary", "%s(): failed to start pcms", "audio_test");
    pthread_mutex_unlock(&a1->lock);
    return -22;
  }
  v13 = (struct pcm *)pcm_open(0, 2, 0x10000000, v28);
  a1->pcm_be_in = v13;
  if ( v13 && !pcm_is_ready() )
  {
    v19 = (const char *)pcm_get_error(a1->pcm_be_in);
    _android_log_print(6, "audio_hw_primary", "pcm_open(VOICE_BE_IN) failed: %s", v19);
LABEL_52:
    pcm_close(a1->pcm_be_out);
    a1->pcm_be_out = 0;
    goto LABEL_53;
  }
  v14 = (struct pcm *)pcm_open(0, 3, 0, v28);
  a1->pcm_voice_out = v14;
  if ( v14 && !pcm_is_ready() )
  {
    v20 = (const char *)pcm_get_error(a1->pcm_voice_out);
    _android_log_print(6, "audio_hw_primary", "pcm_open(VOICE_OUT) failed: %s", v20);
LABEL_51:
    pcm_close(a1->pcm_be_in);
    a1->pcm_be_in = 0;
    goto LABEL_52;
  }
  v15 = (struct pcm *)pcm_open(0, 3, 0x10000000, v28);
  a1->pcm_voice_in = v15;
  if ( v15 && !pcm_is_ready() )
  {
    v21 = (const char *)pcm_get_error(a1->pcm_voice_in);
    _android_log_print(6, "audio_hw_primary", "pcm_open(VOICE_IN) failed: %s", v21);
LABEL_50:
    pcm_close(a1->pcm_voice_out);
    a1->pcm_voice_out = 0;
    goto LABEL_51;
  }
  v16 = (struct pcm *)pcm_open(0, 6, 0, v28);
  a1->pcm_pa_out = v16;
  if ( v16 && !pcm_is_ready() )
  {
    v23 = (const char *)pcm_get_error(a1->pcm_pa_out);
    _android_log_print(6, "audio_hw_primary", "pcm_open(PA_OUT) failed: %s", v23);
LABEL_49:
    pcm_close(a1->pcm_voice_in);
    a1->pcm_voice_in = 0;
    goto LABEL_50;
  }
  v17 = (struct pcm *)pcm_open(0, 6, 0x10000000, v28);
  a1->pcm_pa_in = v17;
  if ( v17 && !pcm_is_ready() )
  {
    v24 = (const char *)pcm_get_error(a1->pcm_pa_in);
    _android_log_print(6, "audio_hw_primary", "pcm_open(PA_IN) failed: %s", v24);
    pcm_close(a1->pcm_pa_out);
    a1->pcm_pa_out = 0;
    goto LABEL_49;
  }
  pcm_prepare(a1->pcm_be_out);
  pcm_prepare(a1->pcm_be_in);
  pcm_prepare(a1->pcm_voice_out);
  pcm_prepare(a1->pcm_voice_in);
  pcm_prepare(a1->pcm_pa_out);
  pcm_prepare(a1->pcm_pa_in);
  if ( v11 == 1 )
  {
    v5 = j_amplifier_calibrate(a1);
    pthread_mutex_unlock(&a1->lock);
    if ( v5 )
      return -1;
  }
  else
  {
    v22 = sub_6D54(a1->mixer, v10, 1);
    if ( v9 == 1 )
    {
      if ( NxpTfa98xx_PowerOn(0, "bluetooth_nrec=%d", 0) )
        _android_log_print(6, "audio_hw_primary", "%s(): failed to power on tfa98xx", "audio_test");
    }
    else if ( NxpTfa98xx_PowerOff(v22) )
    {
      _android_log_print(6, "audio_hw_primary", "%s(): failed to power off tfa98xx", "audio_test");
    }
    pthread_mutex_unlock(&a1->lock);
    return 0;
  }
  return v5;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int pcm_is_ready(void);
// 3068: using guessed type int __fastcall pcm_prepare(_DWORD);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 31F4: using guessed type int __fastcall str_parms_create_str(_DWORD);
// 3200: using guessed type int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD);
// 3254: using guessed type int __fastcall SetAudioVolume(_DWORD);
// 3290: using guessed type int NxpTfa98xx_PowerOn(_DWORD, const char *, ...);
// 32B4: using guessed type int __fastcall NxpTfa98xx_PowerOff(_DWORD);
// 32F0: using guessed type int j_is_headphone_on(void);
// 3308: using guessed type int __fastcall j_amplifier_calibrate(_DWORD);
// 3314: using guessed type int __fastcall SetAudioLoopback(_DWORD, _DWORD);
// 4198: using guessed type int thread_test_hifi();
// 6CBC: using guessed type int __fastcall sub_6CBC(_DWORD);
// 6D54: using guessed type int __fastcall sub_6D54(_DWORD, _DWORD, _DWORD);
// 10DB4: using guessed type char **test_earphones_ptr[9];
// 10DB8: using guessed type char **test_headphone_ptr[8];
// 10DC0: using guessed type char **test_pri_mic_ptr[6];
// 10DC4: using guessed type char **test_sec_mic_ptr[5];
// 10DC8: using guessed type char **test_ter_mic_ptr[4];
// 10DD0: using guessed type char **test_modem_loopback_earphone_ptr[2];
// 10DD4: using guessed type char **test_modem_loopback_headphone_ptr;
// 110F8: using guessed type char *default_settings;
// 11290: using guessed type char *test_speaker;
// 116C8: using guessed type int dword_116C8;
// 116CC: using guessed type int dword_116CC;
// 66B0: using guessed type _QWORD var_70[4];

//----- (00006CBC) --------------------------------------------------------
struct pcm *__fastcall sub_6CBC(audio_device *a1)
{
  struct pcm *pcm_be_out; // r0
  struct pcm *pcm_be_in; // r0
  struct pcm *pcm_voice_out; // r0
  struct pcm *pcm_voice_in; // r0
  struct pcm *pcm_pa_out; // r0
  struct pcm *result; // r0

  pcm_be_out = a1->pcm_be_out;
  if ( pcm_be_out )
  {
    pcm_stop(pcm_be_out);
    pcm_close(a1->pcm_be_out);
    a1->pcm_be_out = 0;
  }
  pcm_be_in = a1->pcm_be_in;
  if ( pcm_be_in )
  {
    pcm_stop(pcm_be_in);
    pcm_close(a1->pcm_be_in);
    a1->pcm_be_in = 0;
  }
  pcm_voice_out = a1->pcm_voice_out;
  if ( pcm_voice_out )
  {
    pcm_stop(pcm_voice_out);
    pcm_close(a1->pcm_voice_out);
    a1->pcm_voice_out = 0;
  }
  pcm_voice_in = a1->pcm_voice_in;
  if ( pcm_voice_in )
  {
    pcm_stop(pcm_voice_in);
    pcm_close(a1->pcm_voice_in);
    a1->pcm_voice_in = 0;
  }
  pcm_pa_out = a1->pcm_pa_out;
  if ( pcm_pa_out )
  {
    pcm_stop(pcm_pa_out);
    pcm_close(a1->pcm_pa_out);
    a1->pcm_pa_out = 0;
  }
  result = a1->pcm_pa_in;
  if ( result )
  {
    pcm_stop(result);
    pcm_close(a1->pcm_pa_in);
    result = 0;
    a1->pcm_pa_in = 0;
  }
  return result;
}
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 31DC: using guessed type int __fastcall pcm_stop(_DWORD);

//----- (00006D54) --------------------------------------------------------
int __fastcall sub_6D54(int result, const char **a2, int a3)
{
  int v5; // r9
  int v6; // r5
  const char **v7; // r4
  int ctl_by_name; // r7
  const char **v9; // r4
  const char *v10; // r1
  int *v11; // r4
  unsigned int v12; // r6
  int v13; // r2
  int v14; // r0
  unsigned int v15; // r1

  v5 = result;
  if ( *a2 )
  {
    v6 = 0;
    v7 = a2;
    while ( 1 )
    {
      ctl_by_name = mixer_get_ctl_by_name(v5);
      if ( !ctl_by_name )
        break;
      v9 = &a2[3 * v6];
      v10 = v9[2];
      if ( v10 )
      {
        if ( !a3 )
          v10 = "Off";
        mixer_ctl_set_enum_by_string(ctl_by_name, v10);
      }
      else if ( mixer_ctl_get_num_values(ctl_by_name) )
      {
        v11 = (int *)(v9 + 1);
        v12 = 0;
        do
        {
          if ( a3 )
          {
            v13 = *v11;
            v14 = ctl_by_name;
            v15 = v12;
          }
          else
          {
            v14 = ctl_by_name;
            v15 = v12;
            v13 = 0;
          }
          mixer_ctl_set_value(v14, v15, v13);
          ++v12;
        }
        while ( v12 < mixer_ctl_get_num_values(ctl_by_name) );
      }
      ++v6;
      result = 3 * v6;
      v7 = &a2[3 * v6];
      if ( !*v7 )
        return result;
    }
    return _android_log_print(6, "audio_hw_primary", "%s(): failed to set ctl: %s ", "set_route_by_array", *v7);
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 2FFC: using guessed type int __fastcall mixer_get_ctl_by_name(_DWORD);
// 3170: using guessed type int __fastcall mixer_ctl_get_num_values(_DWORD);
// 317C: using guessed type int __fastcall mixer_ctl_set_value(_DWORD, _DWORD, _DWORD);
// 3320: using guessed type int __fastcall mixer_ctl_set_enum_by_string(_DWORD, _DWORD);

//----- (00006E08) --------------------------------------------------------
int __fastcall sub_6E08(int a1)
{
  return *(_DWORD *)(a1 + 184);
}

//----- (00006E0E) --------------------------------------------------------
int __fastcall sub_6E0E(int a1, int a2)
{
  *(_DWORD *)(a1 + 184) = a2;
  return 0;
}

//----- (00006E16) --------------------------------------------------------
unsigned int __fastcall sub_6E16(int a1)
{
  return (*(_DWORD *)(a1 + 192) + 15) & 0xFFFFFFF0;
}

//----- (00006E22) --------------------------------------------------------
int __fastcall sub_6E22(int a1)
{
  return *(_DWORD *)(a1 + 168);
}

//----- (00006E28) --------------------------------------------------------
int __fastcall sub_6E28(int a1)
{
  return *(_DWORD *)(a1 + 188);
}

//----- (00006E2E) --------------------------------------------------------
int sub_6E2E()
{
  return -38;
}
// 6E2E: using guessed type int sub_6E2E();

//----- (00006E34) --------------------------------------------------------
int sub_6E34()
{
  return 0;
}
// 6E34: using guessed type int sub_6E34();

//----- (00006E38) --------------------------------------------------------
int __fastcall sub_6E38(int a1, int a2)
{
  int v3; // r5
  pthread_mutex_t *v4; // r10
  int str; // r4
  int v6; // r6
  int v7; // r8
  int v8; // r0
  int v9; // r11
  bool v10; // zf
  int v11; // r8
  char v12; // r2
  bool v13; // zf
  bool v14; // zf
  int v15; // r2
  int v16; // r1
  int v17; // r1
  int v18; // r0
  int v19; // r0
  int v20; // r2
  int v21; // r1
  int v22; // r1
  int v23; // r0
  int v24; // r6
  char v25; // r1
  int v26; // r6
  char v27; // r1
  int v28; // r6
  const char *v29; // r1
  int v30; // r2
  char v31; // r0
  char nptr[32]; // [sp+10h] [bp-48h] BYREF

  v3 = *(_DWORD *)(a1 + 204);
  v4 = *(pthread_mutex_t **)(v3 + 252);
  str = str_parms_create_str(a2);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 164));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 100));
  if ( str_parms_get_str(str, "routing", nptr, 32) < 0 )
  {
    v7 = 0;
    goto LABEL_10;
  }
  v6 = atoi(nptr);
  v7 = 0;
  if ( !v6 )
  {
LABEL_10:
    v9 = 0;
    goto LABEL_58;
  }
  v8 = *(_DWORD *)(v3 + 172);
  v9 = 0;
  if ( v8 != v6 )
  {
    v10 = (v6 & 0x1000) == (*(_DWORD *)(v3 + 172) & 0x1000);
    if ( (v6 & 0x1000) == (*(_DWORD *)(v3 + 172) & 0x1000) )
      v10 = (*(_DWORD *)(v3 + 172) & 0x1000) == 0;
    if ( v10 )
    {
      v11 = 0;
      v9 = 0;
    }
    else
    {
      v12 = (char)v4;
      if ( v4 )
        v12 = 1;
      v11 = (unsigned __int8)v12 & (*(_DWORD *)(a1 + 104) != 0);
      v9 = 1;
    }
    v13 = v8 == 8;
    if ( v8 != 8 )
      v13 = v8 == 4;
    if ( v13 && *(_DWORD *)(v3 + 256) && *(_BYTE *)(v3 + 289) )
      sub_61B8((stream_out *)a1);
    v14 = v6 == 8;
    if ( v6 != 8 )
      v14 = v6 == 4;
    if ( v14 )
    {
      _android_log_print(
        3,
        "audio_hw_primary",
        "%s(): out_device change: (0x%x >> 0x%x)",
        "out_set_parameters",
        *(_DWORD *)(v3 + 172),
        v6);
      if ( *(_DWORD *)(v3 + 256) )
      {
        if ( !*(_DWORD *)(v3 + 168) && *(_BYTE *)(v3 + 288) )
          v9 = 1;
      }
    }
    if ( !*(_BYTE *)(a1 + 160) && *(_DWORD *)(v3 + 168) != 2 )
    {
      v15 = *(_DWORD *)(*(_DWORD *)(a1 + 204) + 256);
      v16 = 0;
      if ( v15 && v15 != a1 )
      {
        if ( *(_BYTE *)(v15 + 160) )
          v16 = 0;
        else
          v16 = *(_DWORD *)(v15 + 164);
      }
      _android_log_print(
        3,
        "audio_hw_primary",
        "%s(): out_device change: (0x%x >> 0x%x)",
        "out_set_parameters",
        *(_DWORD *)(v3 + 172),
        v16 | v6);
      v17 = *(_DWORD *)(*(_DWORD *)(a1 + 204) + 256);
      v18 = 0;
      if ( v17 && v17 != a1 )
      {
        if ( *(_BYTE *)(v17 + 160) )
          v18 = 0;
        else
          v18 = *(_DWORD *)(v17 + 164);
      }
      *(_DWORD *)(v3 + 172) = v18 | v6;
      sub_5730((audio_device *)v3);
      v9 = 1;
      v19 = v11;
      if ( *(_DWORD *)(a1 + 104) )
        v11 = 1;
      if ( !v4 )
        v11 = v19;
    }
    if ( *(_DWORD *)(v3 + 168) == 2 )
    {
      *(_DWORD *)(v3 + 200) = 4;
      v20 = *(_DWORD *)(*(_DWORD *)(a1 + 204) + 256);
      v21 = 0;
      if ( v20 && v20 != a1 )
      {
        if ( *(_BYTE *)(v20 + 160) )
          v21 = 0;
        else
          v21 = *(_DWORD *)(v20 + 164);
      }
      _android_log_print(
        3,
        "audio_hw_primary",
        "%s(): out_device change: (0x%x >> 0x%x)",
        "out_set_parameters",
        *(_DWORD *)(v3 + 172),
        v21 | v6);
      v22 = *(_DWORD *)(*(_DWORD *)(a1 + 204) + 256);
      v23 = 0;
      if ( v22 && v22 != a1 )
      {
        if ( *(_BYTE *)(v22 + 160) )
          v23 = 0;
        else
          v23 = *(_DWORD *)(v22 + 164);
      }
      *(_DWORD *)(v3 + 172) = v23 | v6;
      sub_5730((audio_device *)v3);
    }
    *(_DWORD *)(v3 + 172) = v6;
    v7 = v11 != 0;
  }
LABEL_58:
  if ( str_parms_get_str(str, "sampling_rate", nptr, 32) >= 0 )
  {
    v24 = atoi(nptr);
    if ( v24 )
    {
      if ( *(_DWORD *)(a1 + 184) != v24 )
      {
        _android_log_print(
          3,
          "audio_hw_primary",
          "%s(): sample_rate change: (%d >> %d)",
          "out_set_parameters",
          *(_DWORD *)(a1 + 184),
          v24);
        *(_DWORD *)(a1 + 184) = v24;
        *(_DWORD *)(a1 + 192) = sub_7D2C((stream_out *)a1);
        v25 = (char)v4;
        if ( v4 )
          v25 = 1;
        v9 = 1;
        v7 |= (*(_DWORD *)(a1 + 104) != 0) & (unsigned __int8)v25;
      }
    }
  }
  if ( str_parms_get_str(str, "format", nptr, 32) >= 0 )
  {
    v26 = atoi(nptr);
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): format change: (%d >> %d)",
      "out_set_parameters",
      *(_DWORD *)(a1 + 188),
      v26);
    if ( v26 )
    {
      if ( *(_DWORD *)(a1 + 188) != v26 )
      {
        *(_DWORD *)(a1 + 188) = v26;
        *(_DWORD *)(a1 + 192) = sub_7D2C((stream_out *)a1);
        v27 = (char)v4;
        if ( v4 )
          v27 = 1;
        v9 = 1;
        v7 |= (*(_DWORD *)(a1 + 104) != 0) & (unsigned __int8)v27;
      }
    }
  }
  if ( str_parms_get_str(str, "hifi_state", nptr, 32) >= 0 )
  {
    v28 = strcmp(nptr, "on");
    v29 = "Disable";
    if ( !v28 )
      v29 = "Enable";
    _android_log_print(3, "audio_hw_primary", "%s(): %s hifi_card", "out_set_parameters", v29);
    v30 = 0;
    v31 = 0;
    if ( !v28 )
      v30 = 1;
    if ( *(unsigned __int8 *)(v3 + 288) != v30 && !*(_DWORD *)(v3 + 168) && (*(_BYTE *)(v3 + 172) & 0xC) != 0 )
      v9 = 1;
    if ( !v28 )
      v31 = 1;
    *(_BYTE *)(v3 + 288) = v31;
  }
  if ( v9 == 1 )
    sub_61B8((stream_out *)a1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 100));
  if ( v7 == 1 )
  {
    pthread_mutex_lock(v4 + 29);
    sub_605C((int)v4);
    pthread_mutex_unlock(v4 + 29);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 164));
  str_parms_destroy(str);
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 31F4: using guessed type int __fastcall str_parms_create_str(_DWORD);
// 3200: using guessed type int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD);
// 320C: using guessed type int __fastcall str_parms_destroy(_DWORD);

//----- (0000723C) --------------------------------------------------------
char *__fastcall sub_723C(int a1, const char *a2)
{
  int str; // r8
  int v5; // r9
  int v6; // r4
  char *v7; // r1
  int v8; // r6
  char *v9; // t1
  char v10; // r0
  int v11; // r7
  char *v12; // r0
  char *v13; // r4
  char v15[256]; // [sp+0h] [bp-128h] BYREF

  str = str_parms_create_str(a2);
  v5 = str_parms_create();
  if ( str_parms_get_str(str, "sup_channels", v15, 256) < 0 )
  {
    v12 = strdup(a2);
  }
  else
  {
    v6 = 0;
    v15[0] = 0;
    v9 = *(char **)(a1 + 172);
    v8 = a1 + 172;
    v7 = v9;
    if ( v9 )
    {
      v10 = 1;
      do
      {
        v11 = 0;
        while ( (&out_channels_name_to_enum_table)[2 * v11 + 1] != v7 )
        {
          if ( (unsigned int)++v11 >= 3 )
            goto LABEL_11;
        }
        if ( (v10 & 1) == 0 )
          *(_WORD *)&v15[strlen(v15)] = 124;
        _strcat_chk(v15, (&out_channels_name_to_enum_table)[2 * v11], 256);
        v10 = 0;
LABEL_11:
        ++v6;
        v7 = *(char **)(v8 + 4 * v6);
      }
      while ( v7 );
    }
    str_parms_add_str(v5, "sup_channels", v15);
    v12 = (char *)str_parms_to_str(v5);
  }
  v13 = v12;
  str_parms_destroy(str);
  str_parms_destroy(v5);
  return v13;
}
// 31F4: using guessed type int __fastcall str_parms_create_str(_DWORD);
// 3200: using guessed type int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD);
// 320C: using guessed type int __fastcall str_parms_destroy(_DWORD);
// 3218: using guessed type int __fastcall str_parms_to_str(_DWORD);
// 332C: using guessed type int str_parms_create(void);
// 3344: using guessed type int __fastcall _strcat_chk(_DWORD, _DWORD, _DWORD);
// 3350: using guessed type int __fastcall str_parms_add_str(_DWORD, _DWORD, _DWORD);
// 1096C: using guessed type char *out_channels_name_to_enum_table;

//----- (00007320) --------------------------------------------------------
int sub_7320()
{
  return 0;
}
// 7320: using guessed type int sub_7320();

//----- (00007324) --------------------------------------------------------
int sub_7324()
{
  return 0;
}
// 7324: using guessed type int sub_7324();

//----- (00007328) --------------------------------------------------------
unsigned int __fastcall sub_7328(_DWORD *a1)
{
  return (unsigned int)(1000 * a1[32] * a1[31]) / a1[46];
}

//----- (0000733E) --------------------------------------------------------
int sub_733E()
{
  return -38;
}
// 733E: using guessed type int sub_733E();

//----- (00007344) --------------------------------------------------------
unsigned int __fastcall sub_7344(stream_out *a1, int a2, unsigned int a3)
{
  stream_out *v3; // r9
  struct audio_device *adev; // r11
  audio_format_t v6; // r0
  bool v7; // zf
  int v8; // r5
  unsigned int v9; // r4
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  pthread_mutex_t *p_lock; // r10
  struct audio_device *v15; // r4
  _BOOL4 v16; // r10
  void *v_63; // r5
  audio_mode_t amode; // r0
  int v19; // r0
  int *p_sample_rate; // r1
  audio_format_t *p_format; // r2
  audio_devices_t out_device; // r0
  int v23; // r2
  int v24; // r10
  bool v25; // zf
  void *in_sample_rate; // r0
  audio_format_t in_format; // r1
  int v28; // r1
  int v29; // r7
  bool v30; // zf
  unsigned int v_192; // r5
  int v32; // r0
  bool v33; // zf
  int v34; // r6
  int v35; // r8
  unsigned int v36; // r0
  int v37; // r4
  unsigned int v38; // r0
  unsigned int v39; // r0
  unsigned int v40; // r0
  unsigned int v41; // r0
  int v42; // r0
  int sample_rate; // r3
  void *v_124; // r5
  void *v_128; // r6
  audio_format_t format; // r7
  void *v_140; // r3
  void *v_144; // r5
  int v_148; // r6
  int v_152; // r7
  struct pcm *pcm; // r5
  int v52; // r0
  struct pcm **p_pcm; // r7
  int is_ready; // r0
  struct audio_device *v55; // r4
  audio_format_t v56; // r0
  int v57; // r1
  void *v58; // r0
  int v59; // r2
  void *v60; // r3
  void *v61; // r6
  audio_format_t v62; // r7
  unsigned __int64 v63; // r2
  int v64; // r6
  int v65; // r7
  struct pcm *hifi_pcm; // r5
  int v67; // r0
  int v68; // r0
  int v69; // r0
  int v70; // r0
  void *v71; // r0
  const char *error; // r0
  const char *v73; // r0
  const char *v74; // r0
  audio_format_t v75; // r1
  char v76; // r0
  int v77; // r2
  int v78; // r3
  unsigned int v79; // r7
  char v80; // r5
  char v81; // r7
  int v82; // r6
  struct resampler_itfe **resampler; // r0
  unsigned int v84; // r0
  stream_out *v85; // r7
  int v86; // r9
  struct pcm **v87; // r11
  int v88; // r5
  int i; // r8
  struct pcm *v90; // r0
  const char *v91; // r0
  audio_format_t v92; // r2
  int v93; // r1
  int v94; // r0
  bool v95; // zf
  int v96; // r5
  int v97; // r0
  unsigned int v98; // r0
  unsigned int v99; // r0
  unsigned int v100; // r0
  unsigned int v101; // r0
  unsigned int v103; // [sp+18h] [bp-70h]
  void **p_v_116; // [sp+1Ch] [bp-6Ch]
  struct audio_device *v105; // [sp+20h] [bp-68h]
  pthread_mutex_t *mutex; // [sp+28h] [bp-60h]
  unsigned int v108; // [sp+30h] [bp-58h] BYREF
  unsigned int v109; // [sp+34h] [bp-54h] BYREF
  __int64 v110; // [sp+38h] [bp-50h] BYREF
  unsigned __int64 v111; // [sp+40h] [bp-48h]
  __int64 v112; // [sp+48h] [bp-40h]
  unsigned __int64 v113; // [sp+50h] [bp-38h]
  int v114; // [sp+58h] [bp-30h]
  int v115; // [sp+5Ch] [bp-2Ch]

  v3 = a1;
  adev = a1->adev;
  v6 = a1->stream.common.get_format((const struct audio_stream *)a1);
  v7 = (v6 & 0xFF000000) == 218103808;
  if ( (v6 & 0xFF000000) != 218103808 )
    v7 = (v6 & 0xFF000000) == 0;
  if ( !v7 )
  {
    v9 = 1;
    goto LABEL_19;
  }
  switch ( v6 )
  {
    case AUDIO_FORMAT_PCM_16_BIT:
      goto LABEL_8;
    case AUDIO_FORMAT_PCM_8_BIT:
      v8 = 1;
      break;
    case AUDIO_FORMAT_PCM_32_BIT:
    case AUDIO_FORMAT_PCM_8_24_BIT:
    case AUDIO_FORMAT_PCM_FLOAT:
      v8 = 4;
      break;
    case AUDIO_FORMAT_PCM_24_BIT_PACKED:
      v8 = 3;
      break;
    default:
      if ( v6 == AUDIO_FORMAT_IEC61937 )
LABEL_8:
        v8 = 2;
      else
        v8 = 0;
      break;
  }
  v10 = v3->stream.common.get_channels(&v3->stream.common);
  if ( v10 >> 30 == 2 )
  {
    v11 = v10 & 0x3FFFFFFF;
  }
  else
  {
    if ( v10 >> 30 )
    {
      v13 = 0;
      goto LABEL_18;
    }
    v11 = v10 & 0x3FFFF;
  }
  v12 = ((v11 - ((v11 >> 1) & 0x55555555)) & 0x33333333) + (((v11 - ((v11 >> 1) & 0x55555555)) >> 2) & 0x33333333);
  v13 = (16843009 * ((v12 + (v12 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_18:
  v9 = v13 * v8;
LABEL_19:
  p_lock = &adev->lock;
  v109 = a3 / v9;
  v108 = 4 * (int)off_11010 * unk_11014 / v9;
  pthread_mutex_lock(&adev->lock);
  mutex = &v3->lock;
  pthread_mutex_lock(&v3->lock);
  if ( !LOBYTE(v3->v_160) )
    goto LABEL_102;
  v103 = v9;
  v15 = v3->adev;
  v16 = 0;
  v_63 = v15->v_63;
  v110 = 0LL;
  v111 = 0LL;
  v112 = 0LL;
  v113 = 0LL;
  v114 = 0;
  v115 = 0;
  v15->stream_out = (struct audio_stream_out **)v3;
  _android_log_print(
    3,
    "audio_hw_primary",
    "%s(): mode=%d, out_device=0x%x",
    "start_output_stream",
    v15->amode,
    v15->out_device);
  amode = v15->amode;
  switch ( amode )
  {
    case AUDIO_MODE_RINGTONE:
      v15->b_289 = 0;
      p_sample_rate = &v3->sample_rate;
      v3->sample_rate = v3->in_sample_rate;
      v3->format = AUDIO_FORMAT_DEFAULT;
      p_format = &v3->format;
      break;
    case AUDIO_MODE_IN_COMMUNICATION:
      v16 = 0;
      v19 = 48000;
      v15->b_289 = 0;
      goto LABEL_26;
    case AUDIO_MODE_IN_CALL:
      v16 = 0;
      v15->b_289 = 0;
      v19 = dword_1105C;
LABEL_26:
      v3->sample_rate = v19;
      p_sample_rate = &v3->sample_rate;
      v3->format = AUDIO_FORMAT_DEFAULT;
      p_format = &v3->format;
      break;
    default:
      if ( !v15->hifi_state )
        goto LABEL_31;
      out_device = v15->out_device;
      v23 = 0;
      v24 = 1;
      v25 = out_device == 4;
      if ( out_device != 4 )
        v25 = out_device == 8;
      if ( !v25 )
      {
LABEL_31:
        v24 = 0;
        v23 = 1;
        v15->b_289 = 0;
      }
      in_sample_rate = (void *)v3->in_sample_rate;
      v3->sample_rate = (int)in_sample_rate;
      in_format = v3->in_format;
      if ( in_format == AUDIO_FORMAT_PCM_32_BIT )
      {
        v28 = 1;
      }
      else if ( in_format == AUDIO_FORMAT_PCM_8_24_BIT )
      {
        v28 = 3;
      }
      else
      {
        v28 = 0;
      }
      v3->format = v28;
      v16 = v24 != 0;
      if ( !v23 )
      {
        v29 = 0;
        goto LABEL_42;
      }
      p_sample_rate = &v3->sample_rate;
      p_format = &v3->format;
      break;
  }
  v29 = 1;
  in_sample_rate = (void *)dword_1105C;
  if ( v15->amode != AUDIO_MODE_IN_CALL )
    in_sample_rate = "%s(): voice_call_wb=%d, bluetooth_nrec=%d" + 24;
  *p_sample_rate = (int)in_sample_rate;
  v28 = 0;
  *p_format = AUDIO_FORMAT_DEFAULT;
LABEL_42:
  if ( v_63 && !v16 )
  {
    v30 = off_11034 == in_sample_rate;
    if ( off_11034 == in_sample_rate )
      v30 = dword_11040 == v28;
    if ( !v30 )
    {
      v3->sample_rate = (int)off_11034;
      v3->format = AUDIO_FORMAT_DEFAULT;
    }
  }
  v_192 = (unsigned int)v3->v_192;
  v32 = v3->stream.common.get_format(&v3->stream.common);
  v33 = (v32 & 0xFF000000) == 218103808;
  if ( (v32 & 0xFF000000) != 218103808 )
    v33 = (v32 & 0xFF000000) == 0;
  if ( v33 )
  {
    v34 = a2;
    switch ( v32 )
    {
      case 1:
        goto LABEL_55;
      case 2:
        v35 = 1;
        break;
      case 3:
      case 4:
      case 5:
        v35 = 4;
        break;
      case 6:
        v35 = 3;
        break;
      default:
        if ( v32 == 218103808 )
LABEL_55:
          v35 = 2;
        else
          v35 = 0;
        break;
    }
    v105 = v15;
    v38 = v3->stream.common.get_channels(&v3->stream.common);
    if ( v38 >> 30 == 2 )
    {
      v39 = v38 & 0x3FFFFFFF;
      v37 = v29;
    }
    else
    {
      v37 = v29;
      if ( v38 >> 30 )
      {
        v41 = 0;
        goto LABEL_66;
      }
      v39 = v38 & 0x3FFFF;
    }
    v40 = ((v39 - ((v39 >> 1) & 0x55555555)) & 0x33333333) + (((v39 - ((v39 >> 1) & 0x55555555)) >> 2) & 0x33333333);
    v41 = (16843009 * ((v40 + (v40 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_66:
    v36 = v41 * v35;
    a2 = v34;
    goto LABEL_67;
  }
  v105 = v15;
  v36 = 1;
  v37 = v29;
LABEL_67:
  v42 = v_192 / v36;
  v3->v_124 = (void *)v42;
  p_v_116 = &v3->v_116;
  v3->v_136 = (void *)((int)v3->v_128 * v42);
  sample_rate = v3->sample_rate;
  v_124 = v3->v_124;
  v_128 = v3->v_128;
  format = v3->format;
  LODWORD(v110) = v3->v_116;
  HIDWORD(v110) = sample_rate;
  v111 = __PAIR64__((unsigned int)v_128, (unsigned int)v_124);
  LODWORD(v112) = format;
  v_140 = v3->v_140;
  v_144 = v3->v_144;
  v_148 = (int)v3->v_148;
  v_152 = (int)v3->v_152;
  HIDWORD(v112) = v3->v_136;
  v113 = __PAIR64__((unsigned int)v_144, (unsigned int)v_140);
  v114 = v_148;
  v115 = v_152;
  LODWORD(v111) = 4096;
  if ( v37 == 1 )
  {
    pcm = 0;
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): primary: pcm_open card=%d, device=%d, sample_rate=%d, format=%d, period_size=%d",
      "start_output_stream",
      0,
      v3->devices,
      v3->sample_rate,
      v3->format,
      4096);
    v52 = pcm_open(0, v3->devices, 8, &v110);
    v3->pcm = (struct pcm *)v52;
    if ( v52 )
    {
      p_pcm = &v3->pcm;
      is_ready = pcm_is_ready();
      pcm = v3->pcm;
      if ( !is_ready )
      {
        error = (const char *)pcm_get_error(*p_pcm);
        _android_log_print(
          6,
          "audio_hw_primary",
          "%s(): pcm_open(PCM_CARD_PRIMARY) failed: %s",
          "start_output_stream",
          error);
        v55 = v105;
        p_lock = &adev->lock;
LABEL_97:
        if ( *p_pcm )
        {
          pcm_close();
          *p_pcm = 0;
        }
        v55->stream_out = 0;
        pthread_mutex_unlock(p_lock);
        pthread_mutex_unlock(mutex);
        goto LABEL_141;
      }
    }
    pcm_prepare(pcm);
  }
  v7 = v16;
  v55 = v105;
  p_lock = &adev->lock;
  if ( v7 )
  {
    v56 = v3->format;
    if ( v56 )
    {
      v57 = v111;
    }
    else
    {
      v3->format = AUDIO_FORMAT_PCM_32_BIT;
      v105->b_314 = 1;
      v58 = malloc(4 * (_DWORD)off_11010 * unk_11014);
      v105->v_79 = v58;
      if ( !v58 )
      {
LABEL_96:
        free(v105->v_79);
        p_pcm = &v3->pcm;
        goto LABEL_97;
      }
      memset(v58, 0, 4 * (_DWORD)off_11010 * unk_11014);
      v59 = v3->sample_rate;
      v60 = v3->v_124;
      v61 = v3->v_128;
      v62 = v3->format;
      LODWORD(v110) = *p_v_116;
      HIDWORD(v110) = v59;
      v111 = __PAIR64__((unsigned int)v61, (unsigned int)v60);
      LODWORD(v112) = v62;
      v63 = *(_QWORD *)&v3->v_140;
      v64 = (int)v3->v_148;
      v65 = (int)v3->v_152;
      HIDWORD(v112) = v3->v_136;
      v113 = v63;
      v114 = v64;
      v115 = v65;
      v57 = 4096;
      LODWORD(v111) = 4096;
      v56 = v3->format;
    }
    hifi_pcm = 0;
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): hifi: pcm_open card=%d, device=%d, sample_rate=%d,format=%d, period_size=%d",
      "start_output_stream",
      1,
      0,
      v3->sample_rate,
      v56,
      v57);
    v67 = pcm_open(1, 0, 8, &v110);
    v3->hifi_pcm = (struct pcm *)v67;
    if ( v67 )
    {
      v68 = pcm_is_ready();
      hifi_pcm = v3->hifi_pcm;
      if ( !v68 )
      {
        v73 = (const char *)pcm_get_error(v3->hifi_pcm);
        _android_log_print(
          6,
          "audio_hw_primary",
          "%s(): pcm_open(PCM_CARD_HIFI) failed: %s",
          "start_output_stream",
          v73);
LABEL_94:
        if ( v3->hifi_pcm )
        {
          pcm_close();
          v3->hifi_pcm = 0;
        }
        goto LABEL_96;
      }
    }
    pcm_prepare(hifi_pcm);
    v105->b_289 = 1;
  }
  if ( (v105->out_device & 0x1000) != 0 )
  {
    _android_log_print(
      2,
      "audio_hw_primary",
      "%s(): spdif: pcm_open card=%d, device=%d, sample_rate=%d",
      "start_output_stream",
      2,
      v3->devices,
      v3->sample_rate);
    v69 = pcm_open(2, v3->devices, 8, p_v_116);
    v3->spdif_pcm = (struct pcm *)v69;
    if ( v69 )
    {
      if ( !pcm_is_ready() )
      {
        v74 = (const char *)pcm_get_error(v3->spdif_pcm);
        _android_log_print(
          6,
          "audio_hw_primary",
          "%s(): pcm_open(PCM_CARD_SPDIF) failed: %s",
          "start_output_stream",
          v74);
LABEL_92:
        if ( v3->spdif_pcm )
        {
          pcm_close();
          v3->spdif_pcm = 0;
        }
        goto LABEL_94;
      }
    }
  }
  if ( v105->amode == AUDIO_MODE_IN_CALL )
    v105->v_50 = &byte_4;
  sub_5730(v105);
  v70 = v3->sample_rate;
  if ( v70 != v3->in_sample_rate )
  {
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): create_resampler: (%d >> %d)",
      "start_output_stream",
      v3->in_sample_rate,
      v70);
    v71 = malloc(4 * (_DWORD)off_11010 * unk_11014);
    v3->v_200 = v71;
    if ( !v71 )
      goto LABEL_92;
    memset(v71, 0, 4 * (_DWORD)off_11010 * unk_11014);
    if ( create_resampler(v3->in_sample_rate, v3->sample_rate, 2, 4, 0, &v3->resampler) )
    {
      free(v3->v_200);
      goto LABEL_92;
    }
    (*(void (**)(void))v3->resampler)();
  }
  v9 = v103;
  LOBYTE(v3->v_160) = 0;
LABEL_102:
  pthread_mutex_unlock(p_lock);
  j_pcm_data_dump("/sdcard/Android/log/audio_dump/audio_hw_out1.pcm", a2, a3, "audio.hw.pcm.dump");
  v75 = v3->in_format;
  if ( v75 != AUDIO_FORMAT_PCM_16_BIT && v3->format == AUDIO_FORMAT_DEFAULT )
  {
    v76 = 16;
    if ( v75 == AUDIO_FORMAT_PCM_8_24_BIT )
      v76 = 8;
    if ( a3 >> 2 )
    {
      v77 = 0;
      do
      {
        *(_WORD *)(a2 + 2 * v77) = *(int *)(a2 + 4 * v77) >> v76;
        ++v77;
      }
      while ( a3 >> 2 != v77 );
    }
    v9 >>= 1;
    v109 = (a3 >> 1) / v9;
    v108 = 4 * unk_11014 * (int)off_11010 / v9;
  }
  if ( adev->b_314 && adev->b_289 )
  {
    if ( a3 >> 1 )
    {
      v78 = 0;
      do
      {
        v79 = 127 * *(__int16 *)(a2 + 2 * v78);
        *((_BYTE *)adev->v_79 + 4 * v78 + 1) = v79 >> 7;
        v80 = v79 >> 15;
        v81 = 2 * v79;
        *((_BYTE *)adev->v_79 + 4 * v78 + 2) = v80;
        v82 = (int)adev->v_79 + 4 * v78;
        if ( *(char *)(a2 + 2 * v78 + 1) <= -1 )
          *(_BYTE *)(v82 + 3) = -1;
        else
          *(_BYTE *)(v82 + 3) = 0;
        *((_BYTE *)adev->v_79 + 4 * v78++) = v81;
      }
      while ( a3 >> 1 != v78 );
    }
    v9 *= 2;
    v109 = 2 * a3 / v9;
    v108 = 4 * unk_11014 * (int)off_11010 / v9;
  }
  resampler = v3->resampler;
  if ( resampler )
  {
    if ( adev->b_314 && adev->b_289 )
      a2 = (int)adev->v_79;
    ((void (__fastcall *)(struct resampler_itfe **, int, unsigned int *, void *, unsigned int *))resampler[2])(
      resampler,
      a2,
      &v109,
      v3->v_200,
      &v108);
    a2 = (int)v3->v_200;
    v84 = v108;
  }
  else
  {
    v84 = v109;
    v108 = v109;
    if ( adev->b_314 && adev->b_289 )
      a2 = (int)adev->v_79;
  }
  v85 = v3;
  v86 = a2;
  j_pcm_data_dump("/sdcard/Android/log/audio_dump/audio_hw_out2.pcm", a2, v84 * v9, "audio.hw.pcm.dump");
  v87 = &v85->pcm;
  v88 = 0;
  for ( i = 0; i != 3; ++i )
  {
    v90 = v87[i];
    if ( v90 )
    {
      v88 = pcm_write(v90, v86, v108 * v9);
      if ( v88 )
      {
        v91 = (const char *)pcm_get_error(v87[i]);
        _android_log_print(6, "audio_hw_primary", "%s: ret=%d, card_device = %d, error=%s", "out_write", v88, i, v91);
      }
      else
      {
        v92 = v85->in_format;
        switch ( v92 )
        {
          case AUDIO_FORMAT_PCM_16_BIT:
            goto LABEL_134;
          case AUDIO_FORMAT_PCM_8_BIT:
            v93 = 1;
            break;
          case AUDIO_FORMAT_PCM_32_BIT:
          case AUDIO_FORMAT_PCM_8_24_BIT:
          case AUDIO_FORMAT_PCM_FLOAT:
            v93 = 4;
            break;
          case AUDIO_FORMAT_PCM_24_BIT_PACKED:
            v93 = 3;
            break;
          default:
            if ( v92 == AUDIO_FORMAT_IEC61937 )
LABEL_134:
              v93 = 2;
            else
              v93 = 0;
            break;
        }
        v88 = 0;
        *(_QWORD *)&v85->v_208 += a3 / ((int)v85->v_116 * v93);
      }
    }
  }
  pthread_mutex_unlock(mutex);
  v3 = v85;
  if ( v88 )
  {
LABEL_141:
    v94 = v3->stream.common.get_format(&v3->stream.common);
    v95 = (v94 & 0xFF000000) == 218103808;
    if ( (v94 & 0xFF000000) != 218103808 )
      v95 = (v94 & 0xFF000000) == 0;
    if ( !v95 )
    {
      v97 = 1;
LABEL_159:
      usleep(1000000 * a3 / (v3->in_sample_rate * v97));
      return a3;
    }
    switch ( v94 )
    {
      case 1:
        goto LABEL_148;
      case 2:
        v96 = 1;
        break;
      case 3:
      case 4:
      case 5:
        v96 = 4;
        break;
      case 6:
        v96 = 3;
        break;
      default:
        if ( v94 == 218103808 )
LABEL_148:
          v96 = 2;
        else
          v96 = 0;
        break;
    }
    v98 = v3->stream.common.get_channels(&v3->stream.common);
    if ( v98 >> 30 == 2 )
    {
      v99 = v98 & 0x3FFFFFFF;
    }
    else
    {
      if ( v98 >> 30 )
      {
        v101 = 0;
        goto LABEL_158;
      }
      v99 = v98 & 0x3FFFF;
    }
    v100 = ((v99 - ((v99 >> 1) & 0x55555555)) & 0x33333333) + (((v99 - ((v99 >> 1) & 0x55555555)) >> 2) & 0x33333333);
    v101 = (16843009 * ((v100 + (v100 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_158:
    v97 = v101 * v96;
    goto LABEL_159;
  }
  return a3;
}
// 4: using guessed type char;
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int pcm_is_ready(void);
// 3068: using guessed type int __fastcall pcm_prepare(_DWORD);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int pcm_close(void);
// 3134: using guessed type int __fastcall pcm_write(_DWORD, _DWORD, _DWORD);
// 3368: using guessed type int __fastcall create_resampler(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 3374: using guessed type int __fastcall j_pcm_data_dump(_DWORD, _DWORD, _DWORD, _DWORD);
// 5730: using guessed type int __fastcall sub_5730(_DWORD);
// 11010: using guessed type void *off_11010;
// 11034: using guessed type void *off_11034;
// 11040: using guessed type int dword_11040;
// 1105C: using guessed type int dword_1105C;

//----- (00007C90) --------------------------------------------------------
int sub_7C90()
{
  return -22;
}
// 7C90: using guessed type int sub_7C90();

//----- (00007C96) --------------------------------------------------------
int sub_7C96()
{
  return -22;
}
// 7C96: using guessed type int sub_7C96();

//----- (00007C9C) --------------------------------------------------------
int __fastcall sub_7C9C(int a1, _QWORD *a2, int a3)
{
  pthread_mutex_t *v4; // r9
  int v7; // r6
  int v8; // r0
  __int64 v9; // r0
  int v10; // r5
  unsigned int v12; // [sp+0h] [bp-28h] BYREF

  v4 = (pthread_mutex_t *)(a1 + 100);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 100));
  v7 = 0;
  while ( 1 )
  {
    v8 = *(_DWORD *)(a1 + 104 + 4 * v7);
    if ( v8 )
    {
      if ( !pcm_get_htimestamp(v8, &v12, a3) )
        break;
    }
    if ( ++v7 >= 3 )
      goto LABEL_8;
  }
  v9 = *(_QWORD *)(a1 + 208) - (unsigned int)(*(_DWORD *)(a1 + 128) * *(_DWORD *)(a1 + 124)) + v12;
  if ( v9 >= 0 )
  {
    *a2 = v9;
    v10 = 0;
    goto LABEL_9;
  }
LABEL_8:
  v10 = -1;
LABEL_9:
  pthread_mutex_unlock(v4);
  return v10;
}
// 3380: using guessed type int __fastcall pcm_get_htimestamp(_DWORD, _DWORD, _DWORD);

//----- (00007D2C) --------------------------------------------------------
unsigned int __fastcall sub_7D2C(stream_out *a1)
{
  int v1; // r1
  __int16 *in_sample_rate; // r0
  unsigned int v3; // r4

  v1 = 0;
  in_sample_rate = (__int16 *)a1->in_sample_rate;
  while ( in_sample_rate != off_ED40[2 * v1] )
  {
    if ( (unsigned int)++v1 >= 0xF )
    {
      _android_log_print(
        6,
        "audio_hw_primary",
        "%s(): invalid sampling rate: %d",
        "get_output_buffer_size",
        in_sample_rate);
      return 0;
    }
  }
  v3 = 0x4000 / (unsigned int)off_ED40[2 * v1 + 1];
  _android_log_print(2, "audio_hw_primary", "%s(): buffer_size=%d", "get_output_buffer_size", v3);
  return v3;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// ED40: using guessed type __int16 *off_ED40[2];

//----- (00007DAC) --------------------------------------------------------
int __fastcall sub_7DAC(int a1)
{
  return *(_DWORD *)(a1 + 128);
}

//----- (00007DB2) --------------------------------------------------------
int sub_7DB2()
{
  return 0;
}

//----- (00007DE0) --------------------------------------------------------
int sub_7DE0()
{
  return 16;
}

//----- (00007DE4) --------------------------------------------------------
int sub_7DE4()
{
  return 1;
}

//----- (00007DE8) --------------------------------------------------------
int sub_7DE8()
{
  return -38;
}

//----- (00007DEE) --------------------------------------------------------
int sub_7DEE()
{
  return 0;
}

//----- (00007DF4) --------------------------------------------------------
int __fastcall sub_7DF4(int a1, int a2)
{
  int v3; // r11
  int str; // r10
  int v5; // r7
  _BOOL4 v6; // r5
  int v7; // r7
  int v8; // r4
  int v9; // r1
  int v10; // r0
  int v11; // r0
  int v12; // r4
  int v13; // r0
  char nptr[32]; // [sp+8h] [bp-48h] BYREF

  v3 = *(_DWORD *)(a1 + 172);
  str = str_parms_create_str(a2);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 164));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 116));
  if ( str_parms_get_str(str, "input_source", nptr, 32) < 0 )
  {
    v6 = 0;
  }
  else
  {
    v5 = atoi(nptr);
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): input_source change: (0x%x >> 0x%x)",
      "in_set_parameters",
      *(_DWORD *)(a1 + 156),
      v5);
    v6 = 0;
    if ( v5 && *(_DWORD *)(a1 + 156) != v5 )
    {
      *(_DWORD *)(a1 + 156) = v5;
      v6 = *(_BYTE *)(a1 + 124) == 0;
    }
  }
  v7 = str_parms_get_str(str, "routing", nptr, 32);
  if ( v7 < 0
    || (v8 = atoi(nptr),
        _android_log_print(
          3,
          "audio_hw_primary",
          "%s(): in_device change: (0x%x >> 0x%x)",
          "in_set_parameters",
          *(_DWORD *)(v3 + 176),
          v8),
        !v8)
    || *(_DWORD *)(a1 + 160) == v8 )
  {
    if ( v6 )
      goto LABEL_12;
  }
  else
  {
    *(_DWORD *)(a1 + 160) = v8;
    if ( !*(_BYTE *)(a1 + 124) )
    {
LABEL_12:
      v9 = *(_DWORD *)(v3 + 168);
      if ( v9 == 2 )
        v10 = 4;
      else
        v10 = *(_DWORD *)(a1 + 156);
      *(_DWORD *)(v3 + 200) = v10;
      v11 = *(_DWORD *)(a1 + 160);
      *(_DWORD *)(v3 + 176) = v11;
      v12 = *(_DWORD *)(v3 + 172);
      if ( v9 )
        goto LABEL_23;
      switch ( v11 )
      {
        case -2147483644:
          v13 = 2;
          break;
        case -2147483640:
          v13 = 32;
          break;
        case -2147483632:
          v13 = 4;
          break;
        default:
LABEL_23:
          sub_5730((audio_device *)v3);
          *(_DWORD *)(v3 + 172) = v12;
          goto LABEL_24;
      }
      *(_DWORD *)(v3 + 172) = v13;
      goto LABEL_23;
    }
  }
LABEL_24:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 116));
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 164));
  str_parms_destroy(str);
  return v7;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 31F4: using guessed type int __fastcall str_parms_create_str(_DWORD);
// 3200: using guessed type int __fastcall str_parms_get_str(_DWORD, _DWORD, _DWORD, _DWORD);
// 320C: using guessed type int __fastcall str_parms_destroy(_DWORD);

//----- (00007F84) --------------------------------------------------------
int sub_7F84()
{
  return 0;
}

//----- (00007F88) --------------------------------------------------------
int sub_7F88()
{
  return 0;
}

//----- (00007F8C) --------------------------------------------------------
int sub_7F8C()
{
  return 0;
}

//----- (00007F90) --------------------------------------------------------
unsigned int __fastcall sub_7F90(int a1, char *a2, unsigned int a3)
{
  pthread_mutex_t *v6; // r7
  int v7; // r0
  bool v8; // zf
  int v9; // r4
  unsigned int v10; // r11
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  pthread_mutex_t *v15; // r9
  int v16; // r6
  int v17; // r10
  int v18; // r4
  char *v19; // r0
  _DWORD *v20; // r1
  bool v21; // zf
  int v22; // r0
  int v23; // r4
  Elf32_Sym *v24; // r7
  int v25; // r0
  int v26; // r4
  bool v27; // zf
  int v28; // r7
  int v29; // r0
  const char *error; // r0
  unsigned int v31; // r0
  unsigned int v32; // r0
  unsigned int v33; // r0
  unsigned int v34; // r0
  void *v35; // r0
  void *v36; // r0
  pthread_mutex_t *v37; // r9
  int v38; // r0
  int v39; // r1
  int *v40; // r4
  int v41; // r7
  unsigned int v42; // r0
  int (__fastcall **v43)(int, void *, unsigned int); // r7
  char *v44; // r4
  int v45; // r0
  int v46; // r1
  unsigned int v47; // r1
  int v48; // r2
  int v49; // r0
  int v50; // r11
  char *v51; // r9
  int v52; // r0
  unsigned int v53; // r4
  int v54; // r1
  size_t v55; // r7
  size_t v56; // r3
  unsigned int v57; // r1
  int v58; // r3
  unsigned int v59; // r9
  int v60; // r0
  bool v61; // zf
  int v62; // r4
  signed int v63; // r6
  int v64; // r9
  signed int v65; // r3
  __int64 v66; // kr00_8
  __int64 v67; // r0
  size_t v68; // r7
  int v69; // r0
  int v70; // r0
  unsigned int v71; // r0
  unsigned int v72; // r0
  unsigned int v73; // r0
  unsigned int v74; // r0
  unsigned int v75; // r7
  int i; // r4
  int v77; // r0
  int v78; // r6
  unsigned int v79; // r1
  unsigned int v80; // r0
  unsigned int v81; // r1
  unsigned int j; // r2
  int v83; // r6
  int v84; // r0
  bool v85; // zf
  int v86; // r6
  int v87; // r0
  unsigned int v88; // r0
  unsigned int v89; // r0
  unsigned int v90; // r0
  unsigned int v91; // r0
  pthread_mutex_t *v93; // [sp+14h] [bp-4Ch]
  char *v94; // [sp+28h] [bp-38h]
  int (__fastcall **v95)(int, void *, unsigned int); // [sp+28h] [bp-38h]
  const void *v96; // [sp+2Ch] [bp-34h] BYREF
  int v97; // [sp+30h] [bp-30h]
  int v98; // [sp+34h] [bp-2Ch] BYREF

  v6 = *(pthread_mutex_t **)(a1 + 172);
  v7 = (*(int (__fastcall **)(int))(a1 + 16))(a1);
  v8 = (v7 & 0xFF000000) == 218103808;
  if ( (v7 & 0xFF000000) != 218103808 )
    v8 = (v7 & 0xFF000000) == 0;
  if ( !v8 )
  {
    v94 = a2;
    v10 = 1;
    goto LABEL_19;
  }
  v94 = a2;
  switch ( v7 )
  {
    case 1:
      goto LABEL_8;
    case 2:
      v9 = 1;
      break;
    case 3:
    case 4:
    case 5:
      v9 = 4;
      break;
    case 6:
      v9 = 3;
      break;
    default:
      v94 = a2;
      if ( v7 == 218103808 )
LABEL_8:
        v9 = 2;
      else
        v9 = 0;
      break;
  }
  v11 = (*(int (__fastcall **)(int))(a1 + 12))(a1);
  if ( v11 >> 30 == 2 )
  {
    v12 = v11 & 0x3FFFFFFF;
  }
  else
  {
    if ( v11 >> 30 )
    {
      v14 = 0;
      goto LABEL_18;
    }
    v12 = v11 & 0xFFFC;
  }
  v13 = ((v12 - ((v12 >> 1) & 0x55555555)) & 0x33333333) + (((v12 - ((v12 >> 1) & 0x55555555)) >> 2) & 0x33333333);
  v14 = (16843009 * ((v13 + (v13 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_18:
  v10 = v14 * v9;
LABEL_19:
  v15 = v6 + 41;
  v16 = *(_DWORD *)(a1 + 68);
  v93 = v6;
  pthread_mutex_lock(v6 + 41);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 116));
  if ( !*(_BYTE *)(a1 + 124) )
    goto LABEL_72;
  v17 = *(_DWORD *)(a1 + 172);
  v18 = *(_DWORD *)(v17 + 256);
  _android_log_print(3, "audio_hw_primary", "%s():...", "start_input_stream");
  *(_DWORD *)(v17 + 252) = a1;
  if ( *(_DWORD *)(v17 + 168) == 2 )
  {
    v19 = (char *)dword_1105C;
  }
  else if ( *(_DWORD *)(a1 + 156) == 6 && *(_DWORD *)(a1 + 72) == 1 )
  {
    v19 = (_BYTE *)(&loc_3E7E + 2);
  }
  else
  {
    if ( v18 )
    {
      v20 = (_DWORD *)(v18 + 104);
      if ( *(_DWORD *)(v18 + 104) )
      {
        v19 = *(char **)(v18 + 120);
        v21 = v19 == "bluetooth_nrec=%d";
        if ( v19 != "bluetooth_nrec=%d" )
          v21 = v19 == (char *)&loc_AC44;
        if ( v21 )
        {
          off_11034 = *(void **)(v18 + 120);
          goto LABEL_35;
        }
      }
    }
    v19 = "%s(): voice_call_wb=%d, bluetooth_nrec=%d" + 24;
  }
  off_11034 = v19;
  if ( !v18 )
    goto LABEL_39;
  v20 = (_DWORD *)(v18 + 104);
LABEL_35:
  if ( *v20 && (*(_DWORD *)(v18 + 132) != dword_11040 || *(char **)(v18 + 120) != v19) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 100));
    _android_log_print(2, "audio_hw_primary", "%s(): sync with input stream, standby output", "start_input_stream");
    sub_61B8((stream_out *)v18);
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 100));
    v19 = (char *)off_11034;
  }
LABEL_39:
  _android_log_print(
    2,
    "audio_hw_primary",
    "%s(): pcm_open card=%d, device=%d, sample_rate=%d,channel=%d,format=%d",
    "start_input_stream",
    0,
    0,
    v19,
    pcm_config_in,
    dword_11040);
  v22 = pcm_open(0, 0, 0x10000000, &pcm_config_in);
  *(_DWORD *)(a1 + 120) = v22;
  if ( v22 && !pcm_is_ready(v22) )
  {
    error = (const char *)pcm_get_error(*(_DWORD *)(a1 + 120));
    _android_log_print(
      6,
      "audio_hw_primary",
      "%s(): pcm_open(PCM_CARD_PRIMARY) failed: %s",
      "start_input_stream",
      error);
LABEL_64:
    pcm_close(*(_DWORD *)(a1 + 120));
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(v17 + 252) = 0;
    goto LABEL_65;
  }
  v23 = pcm_config_in;
  v24 = off_11038;
  v25 = (*(int (__fastcall **)(int))(a1 + 16))(a1);
  v26 = v23 * (_DWORD)v24;
  v27 = (v25 & 0xFF000000) == 218103808;
  if ( (v25 & 0xFF000000) != 218103808 )
    v27 = (v25 & 0xFF000000) == 0;
  if ( !v27 )
  {
    v29 = 1;
    goto LABEL_60;
  }
  switch ( v25 )
  {
    case 1:
      goto LABEL_49;
    case 2:
      v28 = 1;
      break;
    case 3:
    case 4:
    case 5:
      v28 = 4;
      break;
    case 6:
      v28 = 3;
      break;
    default:
      if ( v25 == 218103808 )
LABEL_49:
        v28 = 2;
      else
        v28 = 0;
      break;
  }
  v31 = (*(int (__fastcall **)(int))(a1 + 12))(a1);
  if ( v31 >> 30 == 2 )
  {
    v32 = v31 & 0x3FFFFFFF;
  }
  else
  {
    if ( v31 >> 30 )
    {
      v34 = 0;
      goto LABEL_59;
    }
    v32 = v31 & 0xFFFC;
  }
  v33 = ((v32 - ((v32 >> 1) & 0x55555555)) & 0x33333333) + (((v32 - ((v32 >> 1) & 0x55555555)) >> 2) & 0x33333333);
  v34 = (16843009 * ((v33 + (v33 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_59:
  v29 = v34 * v28;
LABEL_60:
  v35 = malloc(v26 * v29);
  *(_DWORD *)(a1 + 144) = v35;
  if ( !v35 )
  {
LABEL_65:
    pthread_mutex_unlock(v15);
    v37 = (pthread_mutex_t *)(a1 + 116);
    goto LABEL_176;
  }
  v36 = *(void **)(a1 + 128);
  if ( v36 != off_11034 )
  {
    *(_DWORD *)(a1 + 136) = sub_8BD4;
    *(_DWORD *)(a1 + 140) = sub_8C90;
    _android_log_print(
      3,
      "audio_hw_primary",
      "%s(): create_resampler: (%d >> %d)",
      "start_input_stream",
      off_11034,
      v36);
    if ( create_resampler(off_11034, *(_DWORD *)(a1 + 128), 1, 4, a1 + 136, a1 + 132) )
    {
      free(*(void **)(a1 + 144));
      goto LABEL_64;
    }
    (**(void (***)(void))(a1 + 132))();
  }
  *(_DWORD *)(a1 + 148) = 0;
  v38 = *(_DWORD *)(v17 + 168);
  if ( v38 == 2 )
  {
    *(_DWORD *)(v17 + 200) = 4;
  }
  else
  {
    v39 = *(_DWORD *)(a1 + 156);
    *(_DWORD *)(v17 + 200) = v39;
    if ( !v38 )
    {
      if ( v39 == 4 )
        *(_DWORD *)(v17 + 200) = 0;
      v69 = *(_DWORD *)(a1 + 160);
      *(_DWORD *)(v17 + 176) = v69;
      v40 = (int *)(v17 + 172);
      v41 = *(_DWORD *)(v17 + 172);
      switch ( v69 )
      {
        case -2147483644:
          v70 = 2;
          break;
        case -2147483640:
          v70 = 32;
          break;
        case -2147483632:
          v70 = 4;
          break;
        default:
          goto LABEL_71;
      }
      *v40 = v70;
      goto LABEL_71;
    }
  }
  *(_DWORD *)(v17 + 176) = *(_DWORD *)(a1 + 160);
  v40 = (int *)(v17 + 172);
  v41 = *(_DWORD *)(v17 + 172);
LABEL_71:
  sub_5730((audio_device *)v17);
  *v40 = v41;
  v42 = 100 * *(_DWORD *)(a1 + 128) / 0x3E8u;
  *(_DWORD *)(a1 + 168) = v42;
  *(_WORD *)(a1 + 166) = 0xFFFF / v42;
  *(_WORD *)(a1 + 164) = 0;
  *(_BYTE *)(a1 + 124) = 0;
LABEL_72:
  pthread_mutex_unlock(v15);
  if ( !*(_DWORD *)(a1 + 72) )
  {
    v60 = (*(int (__fastcall **)(int))(a1 + 16))(a1);
    v61 = (v60 & 0xFF000000) == 218103808;
    if ( (v60 & 0xFF000000) != 218103808 )
      v61 = (v60 & 0xFF000000) == 0;
    if ( !v61 )
    {
      v64 = 1;
LABEL_149:
      v75 = a3 / v10;
      for ( i = 0; (int)v75 > i; i += v98 )
      {
        v98 = v75 - i;
        v77 = *(_DWORD *)(a1 + 132);
        if ( v77 )
        {
          (*(void (__fastcall **)(int, char *, int *))(v77 + 4))(v77, &v94[i * v64], &v98);
        }
        else
        {
          v96 = 0;
          v97 = v75 - i;
          sub_8BD4((_DWORD *)(a1 + 136), &v96);
          v78 = v97;
          if ( v96 )
          {
            qmemcpy(&v94[i * v64], v96, v97 * v64);
            v98 = v78;
          }
          *(_DWORD *)(a1 + 148) -= v78;
        }
        v50 = *(_DWORD *)(a1 + 152);
        if ( v50 )
          goto LABEL_160;
      }
      v50 = i;
LABEL_160:
      v79 = *(_DWORD *)(a1 + 168);
      if ( v50 > 0 )
        v50 = 0;
      if ( v79 )
      {
        v80 = *(_DWORD *)(a1 + 164);
        if ( v79 <= v75 )
          v75 = *(_DWORD *)(a1 + 168);
        v37 = (pthread_mutex_t *)(a1 + 116);
        v44 = v94;
        if ( v75 )
        {
          v81 = HIWORD(v80);
          for ( j = 0; j < v75; ++j )
          {
            v83 = (unsigned __int16)v80;
            LOWORD(v80) = v81 + v80;
            *(_WORD *)&v94[2 * j] = (unsigned int)(v83 * *(__int16 *)&v94[2 * j]) >> 16;
          }
          v79 = *(_DWORD *)(a1 + 168);
        }
        *(_WORD *)(a1 + 164) = v80;
        *(_DWORD *)(a1 + 168) = v79 - v75;
      }
      else
      {
        v37 = (pthread_mutex_t *)(a1 + 116);
        v44 = v94;
      }
      goto LABEL_171;
    }
    switch ( v60 )
    {
      case 1:
        goto LABEL_138;
      case 2:
        v62 = 1;
        break;
      case 3:
      case 4:
      case 5:
        v62 = 4;
        break;
      case 6:
        v62 = 3;
        break;
      default:
        if ( v60 == 218103808 )
LABEL_138:
          v62 = 2;
        else
          v62 = 0;
        break;
    }
    v71 = (*(int (__fastcall **)(int))(a1 + 12))(a1);
    if ( v71 >> 30 == 2 )
    {
      v72 = v71 & 0x3FFFFFFF;
    }
    else
    {
      if ( v71 >> 30 )
      {
        v74 = 0;
        goto LABEL_148;
      }
      v72 = v71 & 0xFFFC;
    }
    v73 = ((v72 - ((v72 >> 1) & 0x55555555)) & 0x33333333) + (((v72 - ((v72 >> 1) & 0x55555555)) >> 2) & 0x33333333);
    v74 = (16843009 * ((v73 + (v73 >> 4)) & 0xF0F0F0F)) >> 24;
LABEL_148:
    v64 = v74 * v62;
    goto LABEL_149;
  }
  v43 = (int (__fastcall **)(int, void *, unsigned int))(v16 + 320092);
  v44 = v94;
  while ( 1 )
  {
    *(_DWORD *)(a1 + 88) = a3;
    if ( !*(_DWORD *)(a1 + 84) )
    {
      _android_log_print(4, "audio_hw_primary", "#### start pcm read thread ####");
      if ( pthread_create((pthread_t *)(a1 + 80), 0, (void *(*)(void *))sub_8A58, (void *)a1) <= -1 )
      {
        _android_log_print(6, "audio_hw_primary", "#### pcm_read_thread() thread creation failed ####");
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 84) = 1;
        _android_log_print(4, "audio_hw_primary", "#### Pcm read thread created successfully ####");
      }
    }
    v45 = *(_DWORD *)(a1 + 104);
    if ( v45 && (v46 = *(_DWORD *)(a1 + 100)) != 0 && v45 >= v46 && v45 - v46 <= a3 && *(_DWORD *)(v16 + 4) )
    {
      if ( !*(_DWORD *)(a1 + 76) )
      {
        *(_DWORD *)(a1 + 76) = 1;
        pthread_join(*(_DWORD *)(a1 + 80), 0);
        _android_log_print(3, "audio_hw_primary", "#### Pcm read thread stopped successfully ####");
LABEL_100:
        if ( !*(_DWORD *)v16 )
        {
          _android_log_print(
            2,
            "audio_hw_primary",
            "#### before waiting for first read - %d ####",
            *(_DWORD *)(a1 + 104));
          do
          {
            usleep(0x3E8u);
            v58 = *(_DWORD *)(a1 + 104);
          }
          while ( !v58 );
          _android_log_print(2, "audio_hw_primary", "#### after waiting for first read  - %d ####", v58);
          (*(void (__fastcall **)(int))(v16 + 320076))(v16);
          (*(void (__fastcall **)(int))(v16 + 320084))(v16);
          *(_DWORD *)v16 = 1;
        }
        v50 = 0;
        goto LABEL_105;
      }
    }
    else if ( !*(_DWORD *)(a1 + 76) )
    {
      goto LABEL_100;
    }
    if ( v45 - *(_DWORD *)(a1 + 100) >= a3 )
      goto LABEL_100;
    _android_log_print(2, "audio_hw_primary", "before slim read");
    v47 = *(_DWORD *)(a1 + 96);
    if ( *(_DWORD *)(a1 + 108) + a3 >= v47 )
    {
      _android_log_print(2, "audio_hw_primary", "after slim read");
      goto LABEL_100;
    }
    v48 = *(_DWORD *)(a1 + 104);
    v49 = *(_DWORD *)(a1 + 120);
    if ( v48 + a3 <= v47 )
    {
      v51 = v44;
      v50 = pcm_read(v49, *(_DWORD *)(a1 + 92) + v48, a3);
      v57 = 0;
      if ( !v50 )
        v57 = a3;
      *(_DWORD *)(a1 + 104) += v57;
      *(_DWORD *)(a1 + 108) += v57;
    }
    else
    {
      v95 = v43;
      v50 = pcm_read(v49, v44, a3);
      _android_log_print(
        3,
        "audio_hw_primary",
        "before write overflow - (write offset, max bytes) = (%d, %d)",
        *(_DWORD *)(a1 + 104),
        *(_DWORD *)(a1 + 96));
      v51 = v44;
      v52 = *(_DWORD *)(a1 + 104);
      v53 = 0;
      v54 = *(_DWORD *)(a1 + 96);
      if ( !v50 )
        v53 = a3;
      v55 = v52 + v53 - v54;
      if ( v54 - v52 >= 1 )
        qmemcpy((void *)(v52 + *(_DWORD *)(a1 + 92)), v51, v54 - v52);
      *(_DWORD *)(a1 + 104) = 0;
      qmemcpy(*(void **)(a1 + 92), &v51[v53 - v55], v55);
      v56 = *(_DWORD *)(a1 + 104) + v55;
      *(_DWORD *)(a1 + 104) = v56;
      *(_DWORD *)(a1 + 108) += v53;
      _android_log_print(3, "audio_hw_primary", "after write overflow - (write offset, max bytes) = (%d, %d)", v56, v53);
      v43 = v95;
    }
    _android_log_print(2, "audio_hw_primary", "after slim read");
    v44 = v51;
    if ( !v50 )
      goto LABEL_100;
LABEL_105:
    if ( *(_DWORD *)(v16 + 4) )
    {
      v59 = 0;
      v63 = a3;
LABEL_122:
      v65 = *(_DWORD *)(a1 + 108);
      if ( v65 >= v63 )
      {
        _android_log_print(3, "audio_hw_primary", "hal read memcpy cvq %d", v63);
        v66 = *(_QWORD *)(a1 + 96);
        if ( HIDWORD(v66) + v63 <= (int)v66 )
        {
          qmemcpy(&v44[v59], (const void *)(*(_DWORD *)(a1 + 92) + HIDWORD(v66)), v63);
          *(_DWORD *)(a1 + 100) += v63;
          *(_DWORD *)(a1 + 108) -= v63;
        }
        else
        {
          _android_log_print(
            3,
            "audio_hw_primary",
            "before read overflow - (read offset, max size) = (%d, %d)",
            HIDWORD(v66),
            (_DWORD)v66);
          v67 = *(_QWORD *)(a1 + 96);
          v68 = HIDWORD(v67) + v63 - v67;
          if ( (int)v67 - HIDWORD(v67) >= 1 )
            qmemcpy(&v44[v59], (const void *)(HIDWORD(v67) + *(_DWORD *)(a1 + 92)), v67 - HIDWORD(v67));
          qmemcpy(&v44[v59 + v63 - v68], *(const void **)(a1 + 92), v68);
          *(_DWORD *)(a1 + 100) = v68;
          *(_DWORD *)(a1 + 108) -= v63;
          _android_log_print(
            3,
            "audio_hw_primary",
            "after read overflow - (read offset, max size) = (%d, %d)",
            v68,
            *(_DWORD *)(a1 + 96));
        }
        _android_log_print(2, "audio_hw_primary", "hal read memcpy end cvq %d", v63);
        _android_log_print(
          2,
          "audio_hw_primary",
          "read/write offset - %d/%d ",
          *(_DWORD *)(a1 + 100),
          *(_DWORD *)(a1 + 104));
      }
      else
      {
        _android_log_print(
          6,
          "audio_hw_primary",
          "#### Not enough data for reading in circular buffer (filled, req) = (%d, %d) ####",
          v65,
          v63);
      }
      goto LABEL_130;
    }
    if ( *(_DWORD *)v16 != 1 )
      goto LABEL_130;
    v59 = (*v43)(v16, v44, a3);
    if ( v59 )
      goto LABEL_110;
    if ( *(_DWORD *)(v16 + 8) )
      break;
    _android_log_print(3, "audio_hw_primary", "CVQ data not ready!");
    usleep(0x2710u);
  }
  v59 = 0;
LABEL_110:
  if ( v59 < a3 && *(_DWORD *)(v16 + 8) )
  {
    _android_log_print(3, "audio_hw_primary", "end of uartstreaming");
    *(_DWORD *)(v16 + 4) = 1;
    (*(void (__fastcall **)(int))(v16 + 320080))(v16);
    a3 = v59;
    v37 = (pthread_mutex_t *)(a1 + 116);
    goto LABEL_175;
  }
  _android_log_print(2, "audio_hw_primary", "hal read strm end cvq %d", v59);
  if ( *(_DWORD *)(v16 + 4) )
  {
    v63 = a3 - v59;
    goto LABEL_122;
  }
LABEL_130:
  v37 = (pthread_mutex_t *)(a1 + 116);
LABEL_171:
  if ( !v50 && LOBYTE(v93[45].__private[0]) )
    memset(v44, 0, a3);
  j_pcm_data_dump("/sdcard/Android/log/audio_dump/audio_hw_in.pcm", (int)v44, a3, (int)"audio.hw.pcm.dump");
LABEL_175:
  if ( v50 <= -1 )
  {
LABEL_176:
    v84 = (*(int (__fastcall **)(int))(a1 + 16))(a1);
    v85 = (v84 & 0xFF000000) == 218103808;
    if ( (v84 & 0xFF000000) != 218103808 )
      v85 = (v84 & 0xFF000000) == 0;
    if ( !v85 )
    {
      v87 = 1;
      goto LABEL_194;
    }
    switch ( v84 )
    {
      case 1:
        goto LABEL_183;
      case 2:
        v86 = 1;
        break;
      case 3:
      case 4:
      case 5:
        v86 = 4;
        break;
      case 6:
        v86 = 3;
        break;
      default:
        if ( v84 == 218103808 )
LABEL_183:
          v86 = 2;
        else
          v86 = 0;
        break;
    }
    v88 = (*(int (__fastcall **)(int))(a1 + 12))(a1);
    if ( v88 >> 30 == 2 )
    {
      v89 = v88 & 0x3FFFFFFF;
LABEL_191:
      v90 = ((v89 - ((v89 >> 1) & 0x55555555)) & 0x33333333) + (((v89 - ((v89 >> 1) & 0x55555555)) >> 2) & 0x33333333);
      v91 = (16843009 * ((v90 + (v90 >> 4)) & 0xF0F0F0F)) >> 24;
    }
    else
    {
      if ( !(v88 >> 30) )
      {
        v89 = v88 & 0xFFFC;
        goto LABEL_191;
      }
      v91 = 0;
    }
    v87 = v91 * v86;
LABEL_194:
    usleep(1000000 * a3 / (*(_DWORD *)(a1 + 128) * v87));
  }
  pthread_mutex_unlock(v37);
  return a3;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3050: using guessed type int __fastcall pcm_open(_DWORD, _DWORD, _DWORD, _DWORD);
// 305C: using guessed type int __fastcall pcm_is_ready(_DWORD);
// 30A4: using guessed type int __fastcall pcm_get_error(_DWORD);
// 30B0: using guessed type int __fastcall pcm_close(_DWORD);
// 3368: using guessed type int __fastcall create_resampler(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 338C: using guessed type int __fastcall pcm_read(_DWORD, _DWORD, _DWORD);
// 11030: using guessed type int pcm_config_in;
// 11034: using guessed type void *off_11034;
// 11038: using guessed type Elf32_Sym *off_11038;
// 11040: using guessed type int dword_11040;
// 1105C: using guessed type int dword_1105C;

//----- (00008A54) --------------------------------------------------------
int sub_8A54()
{
  return 0;
}

//----- (00008A58) --------------------------------------------------------
int __fastcall sub_8A58(int a1)
{
  size_t v2; // r5
  char *v3; // r10
  const char *v4; // r7
  signed int v5; // r0
  int v6; // r1
  const char *v7; // r6
  int v8; // r7
  bool v9; // zf
  int v10; // r0
  size_t v11; // r7
  int v12; // r1
  size_t v13; // r11
  size_t v14; // r3
  size_t v15; // r0

  v2 = *(_DWORD *)(a1 + 88);
  _android_log_print(3, "audio_hw_primary", "%s():...%d", "pcm_read_thread", 898);
  v3 = 0;
  v4 = "%s: before slim read";
  do
  {
    _android_log_print(2, "audio_hw_primary", v4, "pcm_read_thread");
    v5 = *(_DWORD *)(a1 + 96);
    if ( (int)(*(_DWORD *)(a1 + 108) + v2) < v5 )
    {
      v6 = *(_DWORD *)(a1 + 104);
      if ( (int)(v6 + v2) <= v5 )
      {
        v9 = pcm_read(*(_DWORD *)(a1 + 120), v6 + *(_DWORD *)(a1 + 92), v2) == 0;
        v15 = 0;
        if ( v9 )
          v15 = v2;
        *(_DWORD *)(a1 + 104) += v15;
        *(_DWORD *)(a1 + 108) += v15;
      }
      else
      {
        v7 = v4;
        v3 = (char *)malloc(v2);
        if ( !v3 )
          _android_log_print(6, "audio_hw_primary", "%s: malloc fail!!!", "pcm_read_thread");
        v8 = pcm_read(*(_DWORD *)(a1 + 120), v3, v2);
        _android_log_print(
          3,
          "audio_hw_primary",
          "before write overflow %d, %d",
          *(_DWORD *)(a1 + 104),
          *(_DWORD *)(a1 + 96));
        v9 = v8 == 0;
        v10 = *(_DWORD *)(a1 + 104);
        v11 = 0;
        v12 = *(_DWORD *)(a1 + 96);
        if ( v9 )
          v11 = v2;
        v13 = v10 + v11 - v12;
        if ( v12 - v10 >= 1 )
          qmemcpy((void *)(v10 + *(_DWORD *)(a1 + 92)), v3, v12 - v10);
        *(_DWORD *)(a1 + 104) = 0;
        qmemcpy(*(void **)(a1 + 92), &v3[v11 - v13], v13);
        v14 = *(_DWORD *)(a1 + 104) + v13;
        *(_DWORD *)(a1 + 104) = v14;
        *(_DWORD *)(a1 + 108) += v11;
        _android_log_print(3, "audio_hw_primary", "after write overflow %d : %d", v14, v11);
        v4 = v7;
      }
    }
    _android_log_print(2, "audio_hw_primary", "%s: after slim read", "pcm_read_thread");
    usleep(0x2710u);
  }
  while ( !*(_DWORD *)(a1 + 76) );
  if ( v3 )
    free(v3);
  _android_log_print(4, "audio_hw_primary", "#### pcm read thread exit ####");
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 338C: using guessed type int __fastcall pcm_read(_DWORD, _DWORD, _DWORD);

//----- (00008BD4) --------------------------------------------------------
int __fastcall sub_8BD4(_DWORD *a1, _DWORD *a2)
{
  int result; // r0
  int v5; // r6
  Elf32_Sym *v6; // r0
  int v7; // r7
  int v8; // r0
  int v9; // r3
  bool v10; // cf
  unsigned int v11; // r1
  Elf32_Sym *v12; // r1

  result = -22;
  if ( a1 && a2 )
  {
    v5 = *(a1 - 4);
    if ( !v5 )
    {
      *a2 = 0;
      a2[1] = 0;
      result = -19;
      a1[4] = -19;
      return result;
    }
    v6 = (Elf32_Sym *)a1[3];
    if ( !v6 )
    {
      v7 = a1[2];
      v8 = pcm_frames_to_bytes(*(a1 - 4), off_11038);
      v9 = pcm_read(v5, v7, v8);
      a1[4] = v9;
      if ( v9 )
      {
        _android_log_print(6, "audio_hw_primary", "get_next_buffer() pcm_read error %d", v9);
        *a2 = 0;
        a2[1] = 0;
        return a1[4];
      }
      v6 = off_11038;
      v10 = (unsigned int)off_11038 >= 2;
      a1[3] = off_11038;
      if ( v10 )
      {
        v11 = 1;
        do
        {
          *(_WORD *)(a1[2] + 2 * v11) = *(_WORD *)(a1[2] + 4 * v11);
          ++v11;
          v6 = (Elf32_Sym *)a1[3];
        }
        while ( v11 < (unsigned int)v6 );
      }
    }
    v12 = (Elf32_Sym *)a2[1];
    if ( v12 > v6 )
      v12 = v6;
    a2[1] = v12;
    *a2 = a1[2] + 2 * ((_DWORD)off_11038 - a1[3]);
    return a1[4];
  }
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 3104: using guessed type int __fastcall pcm_frames_to_bytes(_DWORD, _DWORD);
// 338C: using guessed type int __fastcall pcm_read(_DWORD, _DWORD, _DWORD);
// 11038: using guessed type Elf32_Sym *off_11038;

//----- (00008C90) --------------------------------------------------------
int __fastcall sub_8C90(int result, int a2)
{
  if ( result )
  {
    if ( a2 )
      *(_DWORD *)(result + 12) -= *(_DWORD *)(a2 + 4);
  }
  return result;
}

//----- (00008C9E) --------------------------------------------------------
int __fastcall audio_route_update_mixer(int a1)
{
  unsigned int v2; // r12
  unsigned int i; // r6
  int v4; // r0
  int v5; // r1
  unsigned int v6; // lr
  unsigned int v7; // r5
  int v8; // r0
  int v9; // r2
  __int64 v10; // kr00_8
  __int64 v11; // r0

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD *)(a1 + 8);
      v5 = v4 + 24 * i;
      v6 = *(_DWORD *)(v5 + 4);
      if ( v6 <= 2 )
      {
        v7 = *(_DWORD *)(v5 + 8);
        if ( v7 )
        {
          v8 = *(_DWORD *)(v4 + 24 * i);
          v9 = 0;
          v10 = *(_QWORD *)(v5 + 12);
          while ( *(_DWORD *)(v10 + 4 * v9) == *(_DWORD *)(HIDWORD(v10) + 4 * v9) )
          {
            if ( ++v9 >= v7 )
              goto LABEL_13;
          }
          if ( v6 == 2 )
            mixer_ctl_set_value(v8, 0, *(_DWORD *)HIDWORD(v10));
          else
            mixer_ctl_set_array(v8);
          v11 = *(_QWORD *)(*(_DWORD *)(a1 + 8) + 24 * i + 12);
          qmemcpy((void *)v11, (const void *)HIDWORD(v11), 4 * v7);
          v2 = *(_DWORD *)(a1 + 4);
        }
      }
LABEL_13:
      ;
    }
  }
  return 0;
}
// 317C: using guessed type int __fastcall mixer_ctl_set_value(_DWORD, _DWORD, _DWORD);
// 33A4: using guessed type int __fastcall mixer_ctl_set_array(_DWORD);

//----- (00008D24) --------------------------------------------------------
unsigned int __fastcall audio_route_reset(int a1)
{
  unsigned int result; // r0
  int v3; // r5
  unsigned int i; // r6
  int v5; // r1

  result = *(_DWORD *)(a1 + 4);
  if ( result )
  {
    v3 = 0;
    for ( i = 0; i < result; ++i )
    {
      v5 = *(_DWORD *)(a1 + 8) + v3;
      if ( *(_DWORD *)(v5 + 4) <= 2u )
      {
        qmemcpy(*(void **)(v5 + 16), *(const void **)(v5 + 20), 4 * *(_DWORD *)(v5 + 8));
        result = *(_DWORD *)(a1 + 4);
      }
      v3 += 24;
    }
  }
  return result;
}

//----- (00008D54) --------------------------------------------------------
int __fastcall audio_route_apply_path(int a1, char *s2)
{
  const char **v4; // r0
  const char **v5; // r5
  int v6; // r6
  unsigned int v7; // r7

  if ( a1 )
  {
    v4 = sub_8DE4(a1, s2);
    v5 = v4;
    if ( v4 )
    {
      if ( v4[2] )
      {
        v6 = 0;
        v7 = 0;
        do
        {
          qmemcpy(
            *(void **)(*(_DWORD *)(a1 + 8) + 24 * *(_DWORD *)&v5[3][v6] + 16),
            *(const void **)&v5[3][v6 + 8],
            4 * *(_DWORD *)&v5[3][v6 + 4]);
          ++v7;
          v6 += 12;
        }
        while ( v7 < (unsigned int)v5[2] );
      }
      return 0;
    }
    else
    {
      _android_log_print(6, "audio_route", "unable to find path '%s'", s2);
      return -1;
    }
  }
  else
  {
    _android_log_print(6, "audio_route", "invalid audio_route");
    return -1;
  }
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00008DE4) --------------------------------------------------------
const char **__fastcall sub_8DE4(int a1, char *s2)
{
  unsigned int v2; // r6
  const char **v4; // r4
  unsigned int v5; // r7

  v2 = *(_DWORD *)(a1 + 16);
  if ( !v2 )
    return 0;
  v4 = *(const char ***)(a1 + 20);
  v5 = 0;
  while ( strcmp(*v4, s2) )
  {
    ++v5;
    v4 += 4;
    if ( v5 >= v2 )
      return 0;
  }
  return v4;
}

//----- (00008E0C) --------------------------------------------------------
int __fastcall audio_route_reset_path(int a1, char *s2)
{
  const char **v4; // r0
  const char **v5; // r5
  int v6; // r6
  unsigned int v7; // r7
  int v8; // r1

  if ( a1 )
  {
    v4 = sub_8DE4(a1, s2);
    v5 = v4;
    if ( v4 )
    {
      if ( v4[2] )
      {
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = *(_DWORD *)(a1 + 8) + 24 * *(_DWORD *)&v5[3][v6];
          qmemcpy(*(void **)(v8 + 16), *(const void **)(v8 + 20), 4 * *(_DWORD *)(v8 + 8));
          ++v7;
          v6 += 12;
        }
        while ( v7 < (unsigned int)v5[2] );
      }
      return 0;
    }
    else
    {
      _android_log_print(6, "audio_route", "unable to find path '%s'", s2);
      return -1;
    }
  }
  else
  {
    _android_log_print(6, "audio_route", "invalid audio_route");
    return -1;
  }
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00008E90) --------------------------------------------------------
_DWORD *__fastcall audio_route_init(int a1, const char *a2)
{
  _DWORD *v4; // r9
  int v5; // r0
  int num_ctls; // r4
  void *v7; // r0
  unsigned int v8; // r6
  int v9; // r4
  int ctl; // r7
  int num_values; // r11
  unsigned int type; // r5
  __int64 v13; // kr00_8
  const char *v14; // r4
  FILE *v15; // r5
  struct XML_ParserStruct *v16; // r0
  struct XML_ParserStruct *v17; // r6
  void *Buffer; // r0
  int v19; // r4
  unsigned int v20; // r0
  int v21; // r4
  unsigned int i; // r7
  int v23; // r2
  int userData[4]; // [sp+8h] [bp-38h] BYREF

  v4 = calloc(1u, 0x18u);
  if ( !v4 )
    return 0;
  v5 = mixer_open(a1);
  *v4 = v5;
  if ( !v5 )
  {
    _android_log_print(6, "audio_route", "Unable to open the mixer, aborting.");
LABEL_35:
    free(v4);
    return 0;
  }
  v4[3] = 0;
  v4[4] = 0;
  v4[5] = 0;
  num_ctls = mixer_get_num_ctls();
  v4[1] = num_ctls;
  v7 = malloc(24 * num_ctls);
  v4[2] = v7;
  if ( !v7 )
  {
LABEL_34:
    mixer_close(*v4);
    goto LABEL_35;
  }
  if ( num_ctls )
  {
    v8 = 0;
    v9 = 20;
    do
    {
      ctl = mixer_get_ctl(*v4, v8);
      num_values = mixer_ctl_get_num_values(ctl);
      *(_DWORD *)(v4[2] + v9 - 20) = ctl;
      *(_DWORD *)(v4[2] + v9 - 12) = num_values;
      type = mixer_ctl_get_type(ctl);
      *(_DWORD *)(v4[2] + v9 - 16) = type;
      if ( type <= 2 )
      {
        *(_DWORD *)(v4[2] + v9 - 8) = malloc(4 * num_values);
        *(_DWORD *)(v4[2] + v9 - 4) = malloc(4 * num_values);
        *(_DWORD *)(v4[2] + v9) = malloc(4 * num_values);
        if ( type == 2 )
          **(_DWORD **)(v4[2] + v9 - 8) = mixer_ctl_get_value(ctl, 0);
        else
          mixer_ctl_get_array(ctl, *(_DWORD *)(v4[2] + v9 - 8), num_values);
        v13 = *(_QWORD *)(v4[2] + v9 - 8);
        qmemcpy((void *)HIDWORD(v13), (const void *)v13, 4 * num_values);
      }
      ++v8;
      v9 += 24;
    }
    while ( v8 < v4[1] );
  }
  v14 = "/system/etc/mixer_paths.xml";
  if ( a2 )
    v14 = a2;
  v15 = fopen(v14, "r");
  if ( !v15 )
  {
    _android_log_print(6, "audio_route", "Failed to open %s", v14);
LABEL_33:
    sub_9570((int)v4);
    goto LABEL_34;
  }
  v16 = XML_ParserCreate(0);
  v17 = v16;
  if ( !v16 )
  {
    _android_log_print(6, "audio_route", "Failed to create XML parser");
LABEL_32:
    fclose(v15);
    goto LABEL_33;
  }
  userData[1] = 0;
  userData[2] = 0;
  userData[0] = (int)v4;
  XML_SetUserData(v16, userData);
  XML_SetElementHandler(v17, (XML_StartElementHandler)sub_9130, (XML_EndElementHandler)sub_9568);
  do
  {
    Buffer = XML_GetBuffer(v17, 1024);
    if ( !Buffer )
      goto LABEL_31;
    v19 = _fread_chk(Buffer, 1, 1024, v15, -1);
    if ( v19 < 0 )
      goto LABEL_31;
    if ( XML_ParseBuffer(v17, v19, v19 == 0) == XML_STATUS_ERROR )
    {
      _android_log_print(6, "audio_route", "Error in mixer xml (%s)", "/system/etc/mixer_paths.xml");
LABEL_31:
      XML_ParserFree(v17);
      goto LABEL_32;
    }
  }
  while ( v19 );
  j_audio_route_update_mixer((int)v4);
  v20 = v4[1];
  if ( v20 )
  {
    v21 = 0;
    for ( i = 0; i < v20; ++i )
    {
      v23 = v4[2] + v21;
      if ( *(_DWORD *)(v23 + 4) <= 2u )
      {
        qmemcpy(*(void **)(v23 + 20), *(const void **)(v23 + 16), 4 * *(_DWORD *)(v23 + 8));
        v20 = v4[1];
      }
      v21 += 24;
    }
  }
  XML_ParserFree(v17);
  fclose(v15);
  return v4;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 2FF0: using guessed type int __fastcall mixer_open(_DWORD);
// 3008: using guessed type int __fastcall mixer_close(_DWORD);
// 30C8: using guessed type int __fastcall _fread_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 3170: using guessed type int __fastcall mixer_ctl_get_num_values(_DWORD);
// 33BC: using guessed type int mixer_get_num_ctls(void);
// 33C8: using guessed type int __fastcall mixer_get_ctl(_DWORD, _DWORD);
// 33D4: using guessed type int __fastcall mixer_ctl_get_type(_DWORD);
// 33E0: using guessed type int __fastcall mixer_ctl_get_value(_DWORD, _DWORD);
// 33EC: using guessed type int __fastcall mixer_ctl_get_array(_DWORD, _DWORD, _DWORD);
// 9130: using guessed type int sub_9130();

//----- (00009130) --------------------------------------------------------
int __fastcall sub_9130(int *a1, char *a2, const char **a3)
{
  const char *v3; // r9
  int v4; // r0
  const char **v5; // r10
  char *v6; // r6
  const char *v7; // r7
  const char *v8; // r11
  int ctl_by_name; // r0
  int v10; // r4
  unsigned int type; // r0
  unsigned int i; // r6
  int v13; // r0
  const char **v14; // r8
  int v15; // r6
  _DWORD *v16; // r4
  unsigned int v17; // r1
  const char *v18; // r9
  int v19; // r0
  unsigned int v20; // r2
  _DWORD *v21; // r3
  signed int v22; // r0
  const char *v23; // r5
  int v24; // r7
  const char *enum_string; // r0
  __int64 v26; // r0
  int v27; // r1
  void *v28; // r0
  int v29; // r0
  unsigned int v30; // r0
  _DWORD *v31; // r1
  unsigned int j; // r5
  unsigned int v33; // r0
  int v34; // r1
  int v35; // r10
  int v36; // r1
  unsigned int v37; // r2
  int v38; // r4
  int v39; // r7
  int num_values; // r8
  unsigned int v41; // r0
  _DWORD *v42; // r1
  int v43; // r4
  const char *v44; // r0
  int v45; // r3
  signed int v46; // r0
  int name; // r3
  int k; // r0
  int result; // r0
  int v50; // [sp+8h] [bp-30h]
  char *s1; // [sp+Ch] [bp-2Ch]

  v3 = *a3;
  v4 = *a1;
  if ( *a3 )
  {
    v5 = a3 + 1;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v50 = v4;
    s1 = a2;
    do
    {
      if ( !strcmp(v3, "name") )
        v6 = (char *)*v5;
      if ( !strcmp(v3, "id") )
      {
        v7 = *v5;
      }
      else if ( !strcmp(v3, "value") )
      {
        v8 = *v5;
      }
      v3 = v5[1];
      v5 += 2;
    }
    while ( v3 );
  }
  else
  {
    v50 = v4;
    s1 = a2;
    v6 = 0;
    v7 = 0;
    v8 = 0;
  }
  if ( !strcmp(s1, "path") )
  {
    if ( !v6 )
    {
      _android_log_print(6, "audio_route", "Unnamed path!");
      goto LABEL_83;
    }
    if ( a1[2] != 1 )
    {
      v14 = sub_8DE4(v50, v6);
      if ( v14[2] )
      {
        v15 = 0;
        v16 = (_DWORD *)a1[1];
        while ( 1 )
        {
          v17 = v16[2];
          v18 = v14[3];
          if ( v17 )
          {
            v19 = *(_DWORD *)&v18[12 * v15];
            v20 = 0;
            v21 = (_DWORD *)v16[3];
            while ( *v21 != v19 )
            {
              ++v20;
              v21 += 3;
              if ( v20 >= v17 )
                goto LABEL_30;
            }
            if ( v20 != -1 )
              break;
          }
LABEL_30:
          v22 = sub_95D4((int)v16);
          if ( v22 >= 0 )
          {
            v23 = &v18[12 * v15];
            v24 = 3 * v22;
            *(_DWORD *)(v16[3] + 12 * v22) = *(_DWORD *)v23;
            *(_DWORD *)(v16[3] + 12 * v22 + 4) = *((_DWORD *)v23 + 1);
            *(_DWORD *)(v16[3] + 4 * v24 + 8) = malloc(4 * *((_DWORD *)v23 + 1));
            qmemcpy(*(void **)(v16[3] + 4 * v24 + 8), *((const void **)v23 + 2), 4 * *((_DWORD *)v23 + 1));
            if ( ++v15 < (unsigned int)v14[2] )
              continue;
          }
          goto LABEL_83;
        }
        name = mixer_ctl_get_name(*(_DWORD *)(*(_DWORD *)(v50 + 8) + 24 * v19));
        _android_log_print(6, "audio_route", "Control '%s' already exists in path '%s'", name, *v16);
      }
      goto LABEL_83;
    }
    if ( sub_8DE4(v50, v6) )
    {
      _android_log_print(6, "audio_route", "Path name '%s' already exists", v6);
      v13 = 0;
    }
    else
    {
      v26 = *(_QWORD *)(v50 + 12);
      if ( (unsigned int)v26 <= HIDWORD(v26) )
      {
        v27 = 2 * v26;
        if ( !(_DWORD)v26 )
          v27 = 8;
        *(_DWORD *)(v50 + 12) = v27;
        v28 = realloc(*(void **)(v50 + 20), 16 * v27);
        if ( !v28 )
        {
          _android_log_print(6, "audio_route", "Unable to allocate more paths");
          v13 = 0;
          goto LABEL_82;
        }
        *(_DWORD *)(v50 + 20) = v28;
      }
      *(_DWORD *)(*(_DWORD *)(v50 + 20) + 16 * *(_DWORD *)(v50 + 16)) = strdup(v6);
      *(_DWORD *)(*(_DWORD *)(v50 + 20) + 16 * *(_DWORD *)(v50 + 16) + 4) = 0;
      *(_DWORD *)(*(_DWORD *)(v50 + 20) + 16 * *(_DWORD *)(v50 + 16) + 8) = 0;
      *(_DWORD *)(*(_DWORD *)(v50 + 20) + 16 * *(_DWORD *)(v50 + 16) + 12) = 0;
      v29 = *(_DWORD *)(v50 + 16);
      *(_DWORD *)(v50 + 16) = v29 + 1;
      v13 = *(_DWORD *)(v50 + 20) + 16 * v29;
    }
LABEL_82:
    a1[1] = v13;
    goto LABEL_83;
  }
  if ( !strcmp(s1, "ctl") )
  {
    ctl_by_name = mixer_get_ctl_by_name(*(_DWORD *)v50);
    v10 = ctl_by_name;
    if ( ctl_by_name )
    {
      type = mixer_ctl_get_type(ctl_by_name);
      if ( type >= 2 )
      {
        if ( type == 2 )
        {
          for ( i = 0; i < mixer_ctl_get_num_enums(v10); ++i )
          {
            enum_string = (const char *)mixer_ctl_get_enum_string(v10, i);
            if ( !strcmp(enum_string, v8) )
              break;
          }
        }
        else
        {
          i = 0;
        }
      }
      else
      {
        i = atoi(v8);
      }
      v30 = *(_DWORD *)(v50 + 4);
      if ( v30 )
      {
        v31 = *(_DWORD **)(v50 + 8);
        for ( j = 0; j < v30; ++j )
        {
          if ( *v31 == v10 )
            break;
          v31 += 6;
        }
      }
      else
      {
        j = 0;
      }
      if ( a1[2] == 1 )
      {
        if ( v7 )
        {
          v33 = atoi(v7);
          v34 = *(_DWORD *)(v50 + 8) + 24 * j;
          if ( v33 >= *(_DWORD *)(v34 + 8) )
          {
            v45 = mixer_ctl_get_name(v10);
            _android_log_print(6, "audio_route", "value id out of range for mixer ctl '%s'", v45);
          }
          else
          {
            *(_DWORD *)(*(_DWORD *)(v34 + 16) + 4 * v33) = i;
          }
        }
        else
        {
          v36 = *(_DWORD *)(v50 + 8);
          if ( *(_DWORD *)(v36 + 24 * j + 8) )
          {
            v37 = 0;
            do
            {
              *(_DWORD *)(*(_DWORD *)(v36 + 24 * j + 16) + 4 * v37++) = i;
              v36 = *(_DWORD *)(v50 + 8);
            }
            while ( v37 < *(_DWORD *)(v36 + 24 * j + 8) );
          }
        }
      }
      else
      {
        if ( v7 )
          v35 = atoi(v7);
        else
          v35 = -1;
        v38 = *(_DWORD *)(*(_DWORD *)(v50 + 8) + 24 * j);
        v39 = a1[1];
        num_values = mixer_ctl_get_num_values(v38);
        if ( v35 >= num_values )
        {
          v44 = (const char *)mixer_ctl_get_name(v38);
          _android_log_print(6, "audio_route", "mixer index %d is out of range for '%s'", v35, v44);
        }
        else
        {
          v41 = *(_DWORD *)(v39 + 8);
          if ( !v41 )
            goto LABEL_72;
          v42 = *(_DWORD **)(v39 + 12);
          v43 = 0;
          while ( *v42 != j )
          {
            ++v43;
            v42 += 3;
            if ( v43 >= v41 )
              goto LABEL_72;
          }
          if ( v43 <= -1 )
          {
LABEL_72:
            v46 = sub_95D4(v39);
            v43 = v46;
            if ( v46 < 0 )
              goto LABEL_83;
            *(_DWORD *)(*(_DWORD *)(v39 + 12) + 12 * v46) = j;
            *(_DWORD *)(*(_DWORD *)(v39 + 12) + 12 * v46 + 4) = num_values;
            *(_DWORD *)(*(_DWORD *)(v39 + 12) + 12 * v46 + 8) = malloc(4 * num_values);
            **(_DWORD **)(*(_DWORD *)(v39 + 12) + 12 * v43 + 8) = i;
          }
          if ( v35 == -1 )
          {
            if ( num_values )
            {
              for ( k = 0; k != num_values; ++k )
                *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v39 + 12) + 12 * v43 + 8) + 4 * k) = i;
            }
          }
          else
          {
            *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v39 + 12) + 12 * v43 + 8) + 4 * v35) = i;
          }
        }
      }
    }
    else
    {
      _android_log_print(6, "audio_route", "Control '%s' doesn't exist - skipping", v6);
    }
  }
LABEL_83:
  result = a1[2] + 1;
  a1[2] = result;
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 2FFC: using guessed type int __fastcall mixer_get_ctl_by_name(_DWORD);
// 3170: using guessed type int __fastcall mixer_ctl_get_num_values(_DWORD);
// 33D4: using guessed type int __fastcall mixer_ctl_get_type(_DWORD);
// 3440: using guessed type int __fastcall mixer_ctl_get_num_enums(_DWORD);
// 344C: using guessed type int __fastcall mixer_ctl_get_enum_string(_DWORD, _DWORD);
// 3464: using guessed type int __fastcall mixer_ctl_get_name(_DWORD);

//----- (00009568) --------------------------------------------------------
int __fastcall sub_9568(int result)
{
  --*(_DWORD *)(result + 8);
  return result;
}

//----- (00009570) --------------------------------------------------------
void __fastcall sub_9570(int a1)
{
  unsigned int v2; // r0
  int v3; // r6
  unsigned int i; // r7
  int v5; // r1

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 )
  {
    v3 = 0;
    for ( i = 0; i < v2; ++i )
    {
      v5 = *(_DWORD *)(a1 + 8) + v3;
      if ( *(_DWORD *)(v5 + 4) <= 2u )
      {
        free(*(void **)(v5 + 12));
        free(*(void **)(*(_DWORD *)(a1 + 8) + v3 + 16));
        free(*(void **)(*(_DWORD *)(a1 + 8) + v3 + 20));
        v2 = *(_DWORD *)(a1 + 4);
      }
      v3 += 24;
    }
  }
  free(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = 0;
}

//----- (000095BA) --------------------------------------------------------
void __fastcall audio_route_free(_DWORD *a1)
{
  sub_9570((int)a1);
  mixer_close(*a1);
  j_free(a1);
}
// 3008: using guessed type int __fastcall mixer_close(_DWORD);

//----- (000095D4) --------------------------------------------------------
unsigned int __fastcall sub_95D4(int a1)
{
  unsigned int result; // r0
  __int64 v3; // kr00_8
  int v4; // r0
  void *v5; // r0

  v3 = *(_QWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 8);
  if ( (unsigned int)v3 > result )
    goto LABEL_6;
  v4 = 2 * v3;
  if ( !(_DWORD)v3 )
    v4 = 8;
  *(_DWORD *)(a1 + 4) = v4;
  v5 = realloc(*(void **)(a1 + 12), 12 * v4);
  if ( v5 )
  {
    *(_DWORD *)(a1 + 12) = v5;
    result = *(_DWORD *)(a1 + 8);
LABEL_6:
    *(_DWORD *)(a1 + 8) = result + 1;
    return result;
  }
  _android_log_print(6, "audio_route", "Unable to allocate more path settings");
  return -1;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00009620) --------------------------------------------------------
int __fastcall get_value(const char *a1, int a2)
{
  int v3; // r0
  int v4; // r5

  if ( a1 && a2 )
  {
    v3 = mixer_open(0);
    v4 = v3;
    if ( v3 )
    {
      if ( mixer_get_ctl_by_name(v3) )
        __debugbreak();
      printf("Invalid control name: %s\n", a1);
      mixer_close(v4);
    }
    else
    {
      puts("Failed to open mixer");
    }
  }
  else
  {
    puts("Invalid control name/value: NULL");
  }
  return -1;
}
// 2FF0: using guessed type int __fastcall mixer_open(_DWORD);
// 2FFC: using guessed type int __fastcall mixer_get_ctl_by_name(_DWORD);
// 3008: using guessed type int __fastcall mixer_close(_DWORD);

//----- (00009674) --------------------------------------------------------
int __fastcall set_value(const char *a1, const char *a2)
{
  int v4; // r0
  int v5; // r4
  int ctl_by_name; // r0
  int v7; // r7
  int type; // r0
  int v9; // r0
  int v10; // r5

  if ( a1 && a2 )
  {
    v4 = mixer_open(0);
    v5 = v4;
    if ( v4 )
    {
      ctl_by_name = mixer_get_ctl_by_name(v4);
      v7 = ctl_by_name;
      if ( ctl_by_name )
      {
        type = mixer_ctl_get_type(ctl_by_name);
        if ( (unsigned int)*(unsigned __int8 *)a2 - 48 > 9 )
        {
          if ( type == 2 )
          {
            if ( !mixer_ctl_set_enum_by_string(v7, a2) )
            {
              v10 = 0;
              goto LABEL_17;
            }
            printf("Error: invalid enum value");
          }
          else
          {
            printf("Error: only enum types can be set with strings");
          }
        }
        else
        {
          v9 = atoi(a2);
          v10 = 0;
          if ( !mixer_ctl_set_value(v7, 0, v9) )
          {
LABEL_17:
            mixer_close(v5);
            return v10;
          }
          printf("Error: invalid value");
        }
      }
      else
      {
        printf("Invalid control name: %s", a1);
      }
      v10 = -1;
      goto LABEL_17;
    }
    printf("Failed to open mixer");
  }
  else
  {
    printf("Invalid control name/value: NULL");
  }
  return -1;
}
// 2FF0: using guessed type int __fastcall mixer_open(_DWORD);
// 2FFC: using guessed type int __fastcall mixer_get_ctl_by_name(_DWORD);
// 3008: using guessed type int __fastcall mixer_close(_DWORD);
// 317C: using guessed type int __fastcall mixer_ctl_set_value(_DWORD, _DWORD, _DWORD);
// 3320: using guessed type int __fastcall mixer_ctl_set_enum_by_string(_DWORD, _DWORD);
// 33D4: using guessed type int __fastcall mixer_ctl_get_type(_DWORD);

//----- (00009728) --------------------------------------------------------
int __fastcall cvq_open(int a1)
{
  int v2; // r0
  int v3; // r3
  FILE *v4; // r3
  int result; // r0
  int v6; // r5
  char *v7; // r0
  int v8[32]; // [sp+8h] [bp-118h] BYREF
  char v9[132]; // [sp+88h] [bp-98h] BYREF

  qmemcpy(v9, "Enable/Disable Streaming PATH/Endpoint", 0x80u);
  memset(v8, 0, sizeof(v8));
  qmemcpy(v8, "32800", 5);
  _android_log_print(3, "CVQStream", "audio cvq %s", "cvq_open");
  v2 = j_set_value(v9, (const char *)v8);
  v3 = *(_DWORD *)(a1 + 320056);
  if ( v2 )
    _android_log_print(6, "CVQStream", "set streaming failed:%p", v3);
  else
    _android_log_print(3, "CVQStream", "set streaming success:%p", v3);
  v4 = fopen("/dev/adnc2", "rb");
  *(_DWORD *)(a1 + 320056) = v4;
  if ( v4 )
  {
    _android_log_print(3, "CVQStream", "uart_char_dev open success:%p", v4);
    result = 0;
  }
  else
  {
    v6 = *(_DWORD *)_errno(0);
    v7 = strerror(v6);
    _android_log_print(6, "CVQStream", "uart_char_dev open failed:%p %d %s", 0, v6, v7);
    result = -1;
  }
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}
// 2FC0: using guessed type int __fastcall _errno(_DWORD);
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00009848) --------------------------------------------------------
int __fastcall cvq_close(_DWORD *a1)
{
  int v2; // r5
  FILE *v3; // r0

  _android_log_print(3, "CVQStream", "audio cvq %s", "cvq_close");
  a1[80018] = 1;
  a1[4] = 0;
  pthread_join(a1[5], 0);
  pthread_join(a1[8], 0);
  v2 = 0;
  v3 = (FILE *)a1[80014];
  if ( v3 )
  {
    v2 = fclose(v3);
    a1[80014] = 0;
    _android_log_print(3, "CVQStream", "#### uart closed, ret = %d ####", v2);
  }
  a1[3] = 0;
  return v2;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (000098C4) --------------------------------------------------------
int __fastcall readdirect(int a1)
{
  if ( *(_DWORD *)(a1 + 8) )
    return 0;
  else
    return (*(int (**)(void))(a1 + 320096))();
}

//----- (000098D8) --------------------------------------------------------
size_t __fastcall cvq_read(_DWORD *a1, char *a2, int a3)
{
  size_t v5; // r6
  int v6; // r7
  unsigned int v7; // r0

  v5 = a3;
  v6 = a1[80013] - a1[80012];
  if ( v6 >= a3 )
    goto LABEL_8;
  if ( a1[2] )
    goto LABEL_6;
  v7 = a1[4];
  a1[4] = v7 + 1;
  if ( v7 >= 0x28 )
  {
    a1[2] = 1;
    _android_log_print(3, "CVQStream", "#### CVQ read timeout, force end ####");
    if ( !a1[2] )
    {
LABEL_7:
      v5 = v6;
LABEL_8:
      a1[4] = 0;
      qmemcpy(a2, (char *)a1 + a1[80012] + 40, v5);
      a1[80012] += v5;
      return v5;
    }
LABEL_6:
    _android_log_print(3, "CVQStream", "#### end of uart data ####");
    goto LABEL_7;
  }
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (0000996C) --------------------------------------------------------
int __fastcall read_on_thread(int a1)
{
  int *v2; // r9
  int v3; // r0
  int v4; // r7
  int v5; // r0
  int v6; // r5

  _android_log_print(3, "CVQStream", "readonthread called");
  _android_log_print(3, "CVQStream", "audio cvq %s", "read_on_thread");
  if ( !*(_DWORD *)(a1 + 320072) )
  {
    v2 = (int *)(a1 + 320052);
    do
    {
      v3 = *v2;
      v4 = 320;
      if ( *v2 + 320 > 160000 )
        v4 = 160000 - v3;
      if ( *(_DWORD *)(a1 + 320040) + v4 <= *(_DWORD *)(a1 + 320044) )
      {
        v5 = (*(int (__fastcall **)(int, int, int))(a1 + 320088))(a1, a1 + 40 + v3, v4);
        v6 = v5;
        if ( v5 >= 1 )
          *v2 += v5;
        usleep(0x3E8u);
        if ( v6 < v4 )
          return 0;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 8) )
          return 0;
        _android_log_print(
          3,
          "CVQStream",
          "#### read_on_thread: UART data read thread lagging so wait till data is available ... ####");
        usleep(0x3E8u);
      }
    }
    while ( !*(_DWORD *)(a1 + 320072) );
  }
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00009A64) --------------------------------------------------------
int __fastcall read_on_raw_data_thread(pthread_t *a1)
{
  int *v2; // r6
  int *v3; // r9
  int v4; // r11
  int v5; // r7
  int v6; // r0
  int wrapper; // r0
  int v8; // r5

  _android_log_print(3, "CVQStream", "#### read_on_raw_data_thread called ####");
  a1[80010] = 0;
  v2 = (int *)(a1 + 80014);
  v3 = (int *)(a1 + 80011);
  v4 = 0;
  do
  {
    if ( a1[80018] )
      break;
    v5 = 4096;
    v6 = *v3;
    if ( *v3 + 4096 > 160000 )
      v5 = 160000 - v6;
    wrapper = j_uart_dev_read_wrapper((int)a1, (int)a1 + v6 + 160040, 1, v5, *v2);
    v8 = wrapper;
    if ( wrapper < 1 )
      break;
    a1[4] = 0;
    *v3 += wrapper;
    if ( !v4 )
    {
      _android_log_print(3, "CVQStream", "#### Start read_on_thread for UART data parsing and decoding ####");
      j_cvq_start_decode(a1);
      v4 = 1;
    }
  }
  while ( v8 >= v5 );
  if ( *v2 )
  {
    fclose((FILE *)*v2);
    *v2 = 0;
    _android_log_print(3, "CVQStream", "#### uart closed ####");
  }
  return 0;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00009B50) --------------------------------------------------------
int __fastcall uart_dev_read_wrapper(int a1, int a2, int a3, int a4, int a5)
{
  int v7; // r3
  int v9; // r6

  v7 = *(_DWORD *)(a1 + 320072);
  if ( v7 )
  {
    _android_log_print(6, "CVQStream", "#### cvqStream->exit = %d, skipping UART read ... ####", v7);
    return -1;
  }
  else
  {
    _android_log_print(3, "CVQStream", "#### Before UART read ####");
    v9 = _fread_chk(a2, a3, a4, a5, -1);
    _android_log_print(3, "CVQStream", "#### After  UART read (req, actual) = (%d, %d) ####", a4 * a3, v9);
  }
  return v9;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 30C8: using guessed type int __fastcall _fread_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00009BD4) --------------------------------------------------------
int __fastcall cvq_start_decode(pthread_t *a1)
{
  int result; // r0

  _android_log_print(3, "CVQStream", "#### Start CVQ UART packet and/or data parsing/decoding called ####");
  result = pthread_create(a1 + 8, 0, (void *(*)(void *))read_on_thread, a1);
  if ( result <= -1 )
    return _android_log_print(6, "CVQStream", "#### read_on_thread() thread creation failed ####");
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00009C24) --------------------------------------------------------
int __fastcall cvq_start(pthread_t *a1)
{
  int result; // r0

  _android_log_print(3, "CVQStream", "#### start CVQ read thread called ####");
  result = pthread_create(a1 + 5, 0, (void *(*)(void *))read_on_raw_data_thread, a1);
  if ( result <= -1 )
    return _android_log_print(6, "CVQStream", "#### read_on_raw_data_thread() thread creation failed ####");
  return result;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 9A64: using guessed type int read_on_raw_data_thread();

//----- (00009C74) --------------------------------------------------------
int __fastcall uart_read_wrapper(_DWORD *a1, char *a2, size_t a3)
{
  size_t v4; // r4
  int v5; // r3
  int v7; // r0

  v4 = a3;
  v5 = a1[80018];
  if ( v5 )
  {
    _android_log_print(6, "CVQStream", "#### cvqStream->exit = %d, skipping UART data decoding ... ####", v5);
  }
  else
  {
    v7 = a1[80010];
    if ( v7 + a3 >= a1[80011] )
    {
      _android_log_print(3, "CVQStream", "#### skipping UART data decoding as UART read thread is lagging ... ####");
      return 0;
    }
    qmemcpy(a2, (char *)a1 + v7 + 160040, a3);
    if ( a2 )
    {
      a1[80010] += v4;
      return v4;
    }
  }
  return -1;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00009D00) --------------------------------------------------------
int __fastcall pcm_read_uart_char_dev(_DWORD *a1, _WORD *a2, int a3)
{
  _WORD *v4; // r4
  int v5; // r10
  char *v6; // r7
  signed int *v7; // r8
  int v8; // r5
  int *v9; // r9
  int v10; // r0
  signed int v11; // r11
  signed int v12; // r2
  int v13; // r0
  int wrapper; // r0
  signed int v15; // r0
  int v16; // r0
  bool v17; // zf
  char *v18; // r1
  _DWORD *v19; // r0
  size_t v20; // r2
  int v21; // r0
  int v22; // r12
  int v23; // lr
  int v24; // r2
  int v25; // r11
  int v26; // r3
  int v27; // r1
  __int16 v28; // r0
  int v29; // r1
  int v30; // lr
  bool v31; // zf
  _DWORD *v32; // r0
  unsigned __int8 *v33; // r0
  int v34; // r2
  int v35; // t1
  _DWORD *v37; // [sp+1Ch] [bp-34h]
  char v38[5]; // [sp+20h] [bp-30h] BYREF
  unsigned __int8 v39; // [sp+25h] [bp-2Bh]
  char v40; // [sp+26h] [bp-2Ah] BYREF
  char v41; // [sp+27h] [bp-29h] BYREF

  v4 = a2;
  v5 = a3 / 2;
  if ( a3 <= 1 )
  {
    v32 = a1 + 3;
    v8 = 0;
  }
  else
  {
    v6 = (char *)a2 + a3 / 2;
    v7 = a1 + 80017;
    v8 = 0;
    v9 = a1 + 80018;
    v37 = a1 + 3;
LABEL_3:
    v10 = *v9;
    v11 = v5 - v8;
    while ( !v10 )
    {
      v12 = *v7;
      if ( *v7 <= v11 )
      {
        if ( v12 < 1 )
          goto LABEL_13;
        wrapper = j_uart_read_wrapper(a1, v6, v12);
        if ( wrapper )
        {
          if ( wrapper == -1 )
            break;
          v15 = *v7;
          *v7 = 0;
          v8 += v15;
          v6 += v15;
LABEL_13:
          if ( a1[2] )
            break;
          v16 = j_uart_read_wrapper(a1, &v40, 2u);
          if ( v16 )
          {
            if ( v16 == -1 )
              break;
            do
            {
              v17 = v40 == 18;
              if ( v40 == 18 )
                v17 = v41 == 52;
              if ( v17 || *v9 )
                break;
              if ( v41 == 18 )
              {
                v18 = &v41;
                v40 = 18;
                v19 = a1;
                v20 = 1;
              }
              else
              {
                v19 = a1;
                v18 = &v40;
                v20 = 2;
              }
            }
            while ( j_uart_read_wrapper(v19, v18, v20) != -1 );
            v21 = j_uart_read_wrapper(a1, v38, 6u);
            if ( v21 )
            {
              if ( v21 == -1 )
                break;
              v22 = v39;
              v23 = (unsigned __int8)v38[0];
              v24 = (unsigned __int8)v38[1];
              v17 = (v39 & 0x40) == 0;
              v25 = v39 & 0x80;
              v26 = (unsigned __int8)(v39 & 0x40) >> 6;
              v27 = (unsigned __int8)v38[2];
              v28 = (unsigned __int8)v38[3];
              a1[2] = v25;
              a1[3] = v26;
              if ( v17 )
              {
                *v9 = 1;
                a1[2] = 1;
                _android_log_print(3, "CVQStream", "#### CVQ read aborted because normal streaming data received ####");
                v8 = 0;
                break;
              }
              v29 = v27 | (__int16)(v28 << 8);
              v30 = v23 | (16 * v24) & 0xF00;
              if ( v29 < 320 )
              {
                if ( v29 != 80 && v29 != 160 )
                  goto LABEL_37;
              }
              else if ( v29 != 320 )
              {
                v31 = v29 == 640;
                if ( v29 != 640 )
                  v31 = v29 == 1280;
                if ( !v31 )
                {
LABEL_37:
                  v25 = 0;
                  v29 = 0;
                  a1[2] = 0;
                }
              }
              *v7 = v29;
              _android_log_print(
                3,
                "CVQStream",
                "#### Frame found - < ID : PKT # : LEN : EOD : MU-Law : EOD_BYTE > = <%5d : %5d : %5d : %5d : %5d : %5d> ####",
                v30,
                v24 & 0xF,
                v29,
                v25,
                v26,
                v22);
            }
          }
LABEL_39:
          if ( v5 > v8 )
            goto LABEL_3;
          break;
        }
      }
      else
      {
        v13 = j_uart_read_wrapper(a1, v6, v5 - v8);
        if ( v13 )
        {
          if ( v13 == -1 )
            break;
          v6 += v11;
          v8 = v5;
          *v7 -= v11;
          goto LABEL_39;
        }
      }
      v10 = *v9;
    }
    v32 = v37;
  }
  if ( *v32 )
  {
    if ( v8 >= 1 )
    {
      v33 = (unsigned __int8 *)v4 + v5;
      v34 = v8;
      do
      {
        v35 = *v33++;
        --v34;
        *v4++ = word_EE88[v35];
      }
      while ( v34 );
    }
    v8 *= 2;
  }
  return v8;
}
// 2FD8: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// EE88: using guessed type _WORD word_EE88[256];

//----- (00009F24) --------------------------------------------------------
int __fastcall cvq_init(int a1)
{
  _QWORD *v1; // r0

  *(_DWORD *)(a1 + 320076) = cvq_open;
  *(_DWORD *)(a1 + 320080) = cvq_close;
  *(_DWORD *)(a1 + 320084) = cvq_start;
  *(_DWORD *)(a1 + 320088) = readdirect;
  *(_DWORD *)(a1 + 320092) = cvq_read;
  *(_DWORD *)(a1 + 320096) = pcm_read_uart_char_dev;
  *(_DWORD *)(a1 + 320068) = 0;
  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 320072) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 320056) = 0;
  v1 = (_QWORD *)(a1 + 320040);
  *v1 = 0LL;
  v1[1] = 0LL;
  return 0;
}
// 9728: using guessed type int cvq_open();
// 9D00: using guessed type int pcm_read_uart_char_dev();

//----- (00009FE0) --------------------------------------------------------
unsigned int *__fastcall sub_9FE0(unsigned int *result, int *a2, int *a3)
{
  unsigned int v3; // r3
  unsigned int v4; // t1
  int v5; // r12
  bool v6; // zf
  int v7; // r3
  int v8; // r12

  v3 = *result;
  if ( (*result & 0x80000000) == 0 )
  {
    *a2 = 1;
    v4 = result[1];
    ++result;
    *a3 = 4 * HIBYTE(v4) + 4;
    return result;
  }
  v5 = HIBYTE(v3) & 0xF;
  if ( v5 )
  {
    v6 = v5 == 3;
    if ( v5 != 3 )
      v6 = v5 == 1;
    if ( !v6 )
      return 0;
    v7 = 4 * BYTE2(v3) + 4;
    v8 = 2;
  }
  else
  {
    v8 = 1;
    v7 = 4;
  }
  *a3 = v7;
  *a2 = v8;
  return result;
}

//----- (0000A034) --------------------------------------------------------
int __fastcall sub_A034(int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v6; // r11
  unsigned int v8; // r7
  int v9; // r10
  int v10; // r2
  unsigned int v11; // r1
  int result; // r0
  int v13; // r3
  int v14; // r2
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r1
  int v19; // r6
  int v20; // r2
  int v21; // r0
  int v22; // r1
  int v23; // r3
  int v24; // r0
  int v25; // r2
  int v26; // r0
  unsigned int v33; // r1
  unsigned int v34; // r0
  int v35; // r1
  unsigned int v36; // r0
  int v37; // [sp+0h] [bp-30h]
  int v38; // [sp+4h] [bp-2Ch] BYREF

  v6 = a3;
  if ( a3 >= a4 )
  {
LABEL_54:
    sub_A928(a1, 14, &v38);
    sub_A956(a1, 15, v38);
    return 8;
  }
  v37 = 0;
  do
  {
    v8 = v6 + 1;
    v9 = *(unsigned __int8 *)(a2 + (v6 ^ 3));
    if ( (v9 & 0x80) == 0 )
    {
      sub_A928(a1, 13, &v38);
      if ( (v9 & 0x40) != 0 )
        v10 = -4 - (unsigned __int8)(4 * v9) + v38;
      else
        v10 = 4 * v9 + v38 + 4;
LABEL_12:
      v38 = v10;
LABEL_13:
      sub_A956(a1, 13, v10);
LABEL_36:
      v6 = v8;
      continue;
    }
    v11 = v9 & 0xF0;
    result = 9;
    if ( v11 > 0xAF )
    {
      if ( v11 == 176 )
      {
        result = 9;
        v18 = 0;
        v19 = 0;
        switch ( *(_BYTE *)(a2 + (v6 ^ 3)) )
        {
          case 0xB0:
            goto LABEL_53;
          case 0xB1:
            if ( v8 >= a4 )
              return 9;
            v20 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
            result = 9;
            if ( !*(_BYTE *)(a2 + (v8 ^ 3)) || (v20 & 0xF0) != 0 )
              return result;
            v21 = a1;
            v22 = 0;
            v23 = 0;
            goto LABEL_48;
          case 0xB2:
            break;
          case 0xB3:
            v23 = 1;
            v26 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
            _R1 = v26 << 12;
            __asm { UXTB16.W        R1, R1 }
            v20 = ((v26 & 0xF) + 1) | _R1;
            v21 = a1;
            v22 = 1;
            goto LABEL_48;
          case 0xB4:
          case 0xB5:
          case 0xB6:
          case 0xB7:
            return result;
          default:
            v16 = 1;
            v13 = 1;
            v14 = ((v9 & 7) + 1) | 0x80000;
            v15 = a1;
            goto LABEL_35;
        }
        while ( v8 < a4 )
        {
          v24 = v8++ ^ 3;
          LOBYTE(v24) = *(_BYTE *)(a2 + v24);
          v25 = (v24 & 0x7F) << v18;
          v18 += 7;
          v19 |= v25;
          if ( (v24 & 0x80) == 0 )
          {
            sub_A928(a1, 13, &v38);
            v10 = v38 + 4 * v19 + 516;
            goto LABEL_12;
          }
        }
        return 9;
      }
      if ( v11 != 192 )
      {
        if ( v11 != 208 )
          return result;
        if ( (v9 & 8) != 0 )
          return 9;
        v16 = 1;
        v14 = ((v9 & 7) + 1) | 0x80000;
        v15 = a1;
LABEL_34:
        v13 = 5;
        goto LABEL_35;
      }
      switch ( *(_BYTE *)(a2 + (v6 ^ 3)) )
      {
        case 0xC0:
        case 0xC1:
        case 0xC2:
        case 0xC3:
        case 0xC4:
        case 0xC5:
          v16 = 3;
          v14 = ((v9 & 7) + 1) | 0xA0000;
          v15 = a1;
          goto LABEL_34;
        case 0xC6:
          v36 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
          if ( (v36 & 0xF) + (v36 >> 4) > 0xF )
            return 9;
          v20 = ((v36 & 0xF) + 1) | (v36 >> 4 << 16);
          v21 = a1;
          v22 = 3;
          break;
        case 0xC7:
          if ( !*(_BYTE *)(a2 + (v8 ^ 3)) || *(unsigned __int8 *)(a2 + (v8 ^ 3)) >= 0x10u )
            return 9;
          goto LABEL_49;
        case 0xC8:
        case 0xC9:
          v33 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
          v34 = v33 >> 4;
          if ( v9 == 200 )
            v34 = (v33 >> 4) | 0x10;
          v35 = v33 & 0xF;
          if ( v34 + v35 > 0x1F )
            return 9;
          v20 = (v35 + 1) | (v34 << 16);
          v21 = a1;
          v22 = 1;
          break;
        default:
          return 9;
      }
      v23 = 5;
LABEL_48:
      sub_A414(v21, v22, v20, v23);
    }
    else
    {
      if ( v11 != 128 )
      {
        if ( v11 == 144 )
        {
          if ( (v9 & 0xD | 2) == 15 )
            return 9;
          sub_A928(a1, v9 & 0xF, &v38);
          v10 = v38;
          goto LABEL_13;
        }
        if ( v11 != 160 )
          return result;
        v13 = 0;
        v14 = ((16 << ((v9 & 7) + 1)) - 16) | (v9 << 11) & 0x4000;
        v15 = a1;
        v16 = 0;
LABEL_35:
        sub_A414(v15, v16, v14, v13);
        goto LABEL_36;
      }
      if ( v8 >= a4 )
        return 9;
      v17 = (unsigned __int16)((_WORD)v9 << 12) | (16 * *(unsigned __int8 *)(a2 + (v8 ^ 3)));
      if ( !v17 )
        return 9;
      sub_A414(a1, 0, v17, 0);
      v37 |= (unsigned __int16)(((_WORD)v9 << 12) & 0x8000) >> 15;
    }
LABEL_49:
    v6 += 2;
  }
  while ( v6 < a4 );
LABEL_53:
  if ( (v37 & 1) == 0 )
    goto LABEL_54;
  return 8;
}

//----- (0000A378) --------------------------------------------------------
int __fastcall sub_A378(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int result; // r0
  int v8; // r2
  int v9; // r0
  int v10; // r1
  __int64 v11; // r2
  int v12; // r1

  switch ( a2 )
  {
    case 0:
      result = 2;
      if ( a3 > 0xF || a4 )
        return result;
      v8 = *a5;
      v9 = a1;
      v10 = a3;
      goto LABEL_11;
    case 1:
      if ( a4 == 5 )
      {
        if ( a3 <= 0x1F )
          goto LABEL_19;
        return 2;
      }
      if ( a4 != 1 || a3 > 0xF )
        return 2;
      sub_AA38(a1);
LABEL_19:
      v11 = *(_QWORD *)a5;
      v12 = a3 + 256;
LABEL_20:
      result = sub_A9CA(a1, v12, v11, SHIDWORD(v11));
LABEL_21:
      if ( result )
        return 2;
      return result;
    case 3:
      result = 2;
      if ( a3 > 0x1F || a4 != 5 )
        return result;
      v11 = *(_QWORD *)a5;
      v12 = a3 + 112;
      goto LABEL_20;
    case 4:
      result = 2;
      if ( a3 > 3 || a4 )
        return result;
      v8 = *a5;
      v10 = a3 + 192;
      v9 = a1;
LABEL_11:
      result = sub_A956(v9, v10, v8);
      goto LABEL_21;
    default:
      sub_A794(
        "_Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation, void *)",
        837,
        "unsupported register class");
  }
}

//----- (0000A414) --------------------------------------------------------
int __fastcall sub_A414(int a1, int a2, unsigned int a3, int a4)
{
  char v8; // r4
  unsigned int i; // r7
  int *v10; // r0
  int v11; // r0
  char v12; // r1
  char v13; // r2
  int result; // r0
  unsigned int v15; // r4
  unsigned int v16; // r6
  int *v17; // r0
  int v18; // r2
  int v19; // r0
  int v20; // r2
  int v21[2]; // [sp+8h] [bp-30h] BYREF
  int *v22; // [sp+10h] [bp-28h] BYREF

  switch ( a2 )
  {
    case 0:
    case 4:
      if ( a4 || sub_A928(a1, 13, v21) )
        return 2;
      v8 = 0;
      for ( i = 0; i < 0x10; ++i )
      {
        if ( ((1 << i) & a3) != 0 )
        {
          v10 = (int *)v21[0];
          v21[0] += 4;
          v22 = (int *)*v10;
          v11 = sub_A378(a1, a2, i, 0, (int *)&v22);
          v12 = 0;
          v13 = 0;
          if ( i == 13 )
            v12 = 1;
          if ( !a2 )
            v13 = 1;
          if ( v11 )
            return 2;
          v8 |= v13 & v12;
        }
      }
      if ( (v8 & 1) != 0 )
        return 0;
      v20 = v21[0];
      goto LABEL_26;
    case 1:
    case 3:
      if ( (a4 | 4) != 5 || sub_A928(a1, 13, &v22) )
        return 2;
      if ( !(_WORD)a3 )
        goto LABEL_21;
      v15 = HIWORD(a3);
      v16 = HIWORD(a3) + (unsigned __int16)a3;
      break;
    default:
      sub_A794(
        "_Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation)",
        971,
        "unsupported register class");
  }
  do
  {
    v17 = v22++;
    v18 = *v17;
    v22 = v17 + 2;
    v19 = v17[1];
    v21[0] = v18;
    v21[1] = v19;
    if ( sub_A378(a1, a2, v15, a4, v21) )
      return 2;
    ++v15;
  }
  while ( v15 < v16 );
LABEL_21:
  if ( a4 == 1 )
    v20 = (int)++v22;
  else
    v20 = (int)v22;
LABEL_26:
  result = sub_A956(a1, 13, v20);
  if ( result )
    return 2;
  return result;
}

//----- (0000A550) --------------------------------------------------------
int __fastcall sub_A550(int a1, int a2, int a3)
{
  return sub_A558(a2, a3);
}

//----- (0000A558) --------------------------------------------------------
int __fastcall sub_A558(int a1, int a2)
{
  int result; // r0
  int v5; // r1
  char v6[8]; // [sp+4h] [bp-3Ch] BYREF
  _DWORD *v7; // [sp+Ch] [bp-34h]

  sub_AA08(a2, (int)v6);
  if ( (*(_BYTE *)(a1 + 80) & 1) == 0 && *v7 )
    return 9;
  v5 = sub_AA02(a2);
  result = 9;
  if ( v5 == 1 )
    return 8;
  return result;
}
// A558: using guessed type char var_3C[8];

//----- (0000A5B4) --------------------------------------------------------
int __fastcall sub_A5B4(int a1, int a2, int a3)
{
  return sub_A558(a2, a3);
}

//----- (0000A5BC) --------------------------------------------------------
int __fastcall sub_A5BC(int a1, int a2, int a3)
{
  return sub_A558(a2, a3);
}

//----- (0000A5C4) --------------------------------------------------------
int __fastcall sub_A5C4(int *a1, int a2, int a3, int a4)
{
  int v5; // r5
  int (__fastcall *v6)(_DWORD, int *, char *); // r3
  int v7; // r0
  int v9[3]; // [sp+0h] [bp-8A0h] BYREF
  int (__fastcall *v10)(_DWORD, int *, char *); // [sp+Ch] [bp-894h]
  int v11; // [sp+14h] [bp-88Ch]
  int v12; // [sp+20h] [bp-880h]
  _DWORD v13[256]; // [sp+28h] [bp-878h] BYREF
  char v14[1120]; // [sp+428h] [bp-478h] BYREF

  sub_A85C(v13, a2, a3, a4, v9[0]);
  a1[3] = 0;
  sub_A8E4((int)v14, v13);
  if ( sub_AA08((int)v14, (int)v9) )
    return 3;
  v5 = 3;
  while ( 1 )
  {
    v6 = v10;
    if ( v10 )
    {
      a1[18] = v9[0];
      a1[19] = v12;
      a1[20] = v11;
      v7 = v6(0, a1, v14);
      if ( v7 != 8 )
        break;
    }
    if ( sub_AA08((int)v14, (int)v9) )
      return 3;
  }
  if ( v7 == 6 )
  {
    sub_A670(v13, a1, 0);
    return 2;
  }
  else if ( v7 == 9 )
  {
    return 9;
  }
  return v5;
}
// A5C4: using guessed type _DWORD var_878[256];

//----- (0000A670) --------------------------------------------------------
int __fastcall sub_A670(const void *a1, int *a2, char a3)
{
  int i; // r6
  int v6; // r7
  int (__fastcall *v7)(int, int *, char *); // r3
  int v8; // r0
  int v10; // [sp+0h] [bp-4B8h] BYREF
  int v11[3]; // [sp+4h] [bp-4B4h] BYREF
  int (__fastcall *v12)(int, int *, char *); // [sp+10h] [bp-4A8h]
  int v13; // [sp+18h] [bp-4A0h]
  int v14; // [sp+24h] [bp-494h]
  int v15; // [sp+2Ch] [bp-48Ch] BYREF
  char v16[1124]; // [sp+30h] [bp-488h] BYREF
  int v17; // [sp+494h] [bp-24h]

  sub_A8E4((int)v16, a1);
  for ( i = 1; ; --i )
  {
    v6 = 1;
    if ( (a3 & 1) != 0 )
    {
      v6 = 2;
      if ( !i )
      {
        sub_A956((int)v16, -1, a2[4]);
        a3 = 0;
      }
    }
    sub_A928((int)v16, -2, &v15);
    if ( sub_AA08((int)v16, (int)v11) )
      break;
    v7 = v12;
    if ( v12 )
    {
      a2[18] = v11[0];
      a2[19] = v14;
      a2[20] = v13;
      v8 = v7(v6, a2, v16);
      if ( v8 == 7 )
      {
        sub_A928((int)v16, -1, &v10);
        a2[4] = v10;
        sub_AA26((int)v16);
        return _stack_chk_guard - v17;
      }
      if ( v8 != 8 )
      {
        if ( v8 == 9 )
          abort();
        return _stack_chk_guard - v17;
      }
      if ( v15 == a2[8] )
        sub_A794(
          "_Unwind_Reason_Code unwind_phase2(unw_context_t *, _Unwind_Exception *, bool)",
          653,
          "during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
    }
  }
  return _stack_chk_guard - v17;
}
// A670: using guessed type int var_4B4[3];

//----- (0000A760) --------------------------------------------------------
void __fastcall __noreturn sub_A760(int *a1, int a2, int a3, int a4)
{
  int v5[260]; // [sp+0h] [bp-410h] BYREF

  sub_A85C(v5, a2, a3, a4, v5[0]);
  sub_A670(v5, a1, 1);
  sub_A794("void _Unwind_Resume(_Unwind_Exception *)", 753, "_Unwind_Resume() can't return");
}

//----- (0000A794) --------------------------------------------------------
void __fastcall __noreturn sub_A794(const char *a1, int a2, const char *a3)
{
  fprintf(stderr, "libunwind: %s %s:%d - %s\n", a1, "external/libunwind_llvm/src/Unwind-EHABI.cpp", a2, a3);
  abort();
}

//----- (0000A7C4) --------------------------------------------------------
int __fastcall sub_A7C4(int a1)
{
  int v1; // r1
  int result; // r0
  char v3[8]; // [sp+4h] [bp-34h] BYREF
  int v4; // [sp+Ch] [bp-2Ch]

  v1 = sub_AA08(a1, (int)v3);
  result = v4;
  if ( v1 )
    return 0;
  return result;
}
// A7C4: using guessed type char var_34[8];

//----- (0000A800) --------------------------------------------------------
int __fastcall sub_A800(int a1)
{
  int v1; // r1
  int result; // r0
  int v3[10]; // [sp+4h] [bp-34h] BYREF

  v1 = sub_AA08(a1, (int)v3);
  result = v3[0];
  if ( v1 )
    return 0;
  return result;
}
// A800: using guessed type int var_34[10];

//----- (0000A848) --------------------------------------------------------
int __fastcall sub_A848(int a1, int a2)
{
  int v2; // r0
  int v3; // r1

  v2 = sub_AA02(a2);
  v3 = 9;
  if ( v2 == 1 )
    return 0;
  return v3;
}

//----- (0000A85C) --------------------------------------------------------
int __fastcall sub_A85C(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int v6; // r5
  int v7; // r6
  int v8; // r7
  int v9; // r8
  int v10; // r9
  int v11; // r10
  int v12; // r11
  int v13; // r12
  int v14; // lr

  *a1 = a1;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = v5;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = v8;
  a1[8] = v9;
  a1[9] = v10;
  a1[10] = v11;
  a1[11] = v12;
  a1[12] = v13;
  a1[13] = &a5;
  a1[14] = v14;
  a1[15] = v14;
  return 0;
}
// A85C: variable 'v5' is possibly undefined
// A85C: variable 'v6' is possibly undefined
// A85C: variable 'v7' is possibly undefined
// A85C: variable 'v8' is possibly undefined
// A85C: variable 'v9' is possibly undefined
// A85C: variable 'v10' is possibly undefined
// A85C: variable 'v11' is possibly undefined
// A85C: variable 'v12' is possibly undefined
// A85C: variable 'v13' is possibly undefined
// A864: variable 'v14' is possibly undefined

//----- (0000A874) --------------------------------------------------------
_QWORD *__fastcall sub_A874(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// A874: variable 'v1' is possibly undefined
// A874: variable 'v2' is possibly undefined
// A874: variable 'v3' is possibly undefined
// A874: variable 'v4' is possibly undefined
// A874: variable 'v5' is possibly undefined
// A874: variable 'v6' is possibly undefined
// A874: variable 'v7' is possibly undefined
// A874: variable 'v8' is possibly undefined
// A874: variable 'v9' is possibly undefined
// A874: variable 'v10' is possibly undefined
// A874: variable 'v11' is possibly undefined
// A874: variable 'v12' is possibly undefined
// A874: variable 'v13' is possibly undefined
// A874: variable 'v14' is possibly undefined
// A874: variable 'v15' is possibly undefined
// A874: variable 'v16' is possibly undefined

//----- (0000A87C) --------------------------------------------------------
_QWORD *__fastcall sub_A87C(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// A87C: variable 'v1' is possibly undefined
// A87C: variable 'v2' is possibly undefined
// A87C: variable 'v3' is possibly undefined
// A87C: variable 'v4' is possibly undefined
// A87C: variable 'v5' is possibly undefined
// A87C: variable 'v6' is possibly undefined
// A87C: variable 'v7' is possibly undefined
// A87C: variable 'v8' is possibly undefined
// A87C: variable 'v9' is possibly undefined
// A87C: variable 'v10' is possibly undefined
// A87C: variable 'v11' is possibly undefined
// A87C: variable 'v12' is possibly undefined
// A87C: variable 'v13' is possibly undefined
// A87C: variable 'v14' is possibly undefined
// A87C: variable 'v15' is possibly undefined
// A87C: variable 'v16' is possibly undefined

//----- (0000A884) --------------------------------------------------------
_QWORD *__fastcall sub_A884(_QWORD *result)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d18
  __int64 v4; // d19
  __int64 v5; // d20
  __int64 v6; // d21
  __int64 v7; // d22
  __int64 v8; // d23
  __int64 v9; // d24
  __int64 v10; // d25
  __int64 v11; // d26
  __int64 v12; // d27
  __int64 v13; // d28
  __int64 v14; // d29
  __int64 v15; // d30
  __int64 v16; // d31

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// A884: variable 'v1' is possibly undefined
// A884: variable 'v2' is possibly undefined
// A884: variable 'v3' is possibly undefined
// A884: variable 'v4' is possibly undefined
// A884: variable 'v5' is possibly undefined
// A884: variable 'v6' is possibly undefined
// A884: variable 'v7' is possibly undefined
// A884: variable 'v8' is possibly undefined
// A884: variable 'v9' is possibly undefined
// A884: variable 'v10' is possibly undefined
// A884: variable 'v11' is possibly undefined
// A884: variable 'v12' is possibly undefined
// A884: variable 'v13' is possibly undefined
// A884: variable 'v14' is possibly undefined
// A884: variable 'v15' is possibly undefined
// A884: variable 'v16' is possibly undefined

//----- (0000A88C) --------------------------------------------------------
void sub_A88C()
{
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (0000A8D0) --------------------------------------------------------
void sub_A8D0()
{
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (0000A8E4) --------------------------------------------------------
int __fastcall sub_A8E4(int a1, const void *a2)
{
  *(_DWORD *)a1 = &off_10C0C;
  *(_DWORD *)(a1 + 4) = &unk_116E0;
  *(_BYTE *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  qmemcpy((void *)(a1 + 8), a2, 0x40u);
  memset((void *)(a1 + 80), 0, 0x1C2u);
  sub_AE00((int *)a1, 0);
  return 0;
}
// 10C0C: using guessed type void *;

//----- (0000A928) --------------------------------------------------------
int __fastcall sub_A928(int a1, int a2, _DWORD *a3)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1 )
    return -6542;
  *a3 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, a2);
  return 0;
}

//----- (0000A956) --------------------------------------------------------
int __fastcall sub_A956(int a1, int a2, int a3)
{
  int v6; // r5

  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1 )
    return -6542;
  (*(void (__fastcall **)(int, int, int))(*(_DWORD *)a1 + 16))(a1, a2, a3);
  if ( a2 != -1 )
    return 0;
  v6 = 0;
  (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 52))(a1, 0);
  return v6;
}

//----- (0000A99A) --------------------------------------------------------
int __fastcall sub_A99A(int a1, int a2, _QWORD *a3)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) != 1 )
    return -6542;
  *a3 = ((__int64 (__fastcall *)(int, int))*(_DWORD *)(*(_DWORD *)a1 + 24))(a1, a2);
  return 0;
}

//----- (0000A9CA) --------------------------------------------------------
int __fastcall sub_A9CA(int a1, int a2, int a3, int a4)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) != 1 )
    return -6542;
  (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)a1 + 28))(a1, a2, a3, a4);
  return 0;
}

//----- (0000AA02) --------------------------------------------------------
int __fastcall sub_AA02(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 32))(a1);
}

//----- (0000AA08) --------------------------------------------------------
int __fastcall sub_AA08(int a1, int a2)
{
  int result; // r0

  (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 36))(a1, a2);
  result = 0;
  if ( !*(_DWORD *)(a2 + 4) )
    return -6549;
  return result;
}

//----- (0000AA26) --------------------------------------------------------
int __fastcall sub_AA26(int a1)
{
  (*(void (__fastcall **)(int))(*(_DWORD *)a1 + 40))(a1);
  return -6540;
}

//----- (0000AA38) --------------------------------------------------------
int __fastcall sub_AA38(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 60))(a1);
}

//----- (0000AA3E) --------------------------------------------------------
int __fastcall sub_AA3E(int a1, int a2)
{
  int v2; // r2
  bool v3; // zf
  int v4; // r0
  unsigned int v5; // r1

  v2 = 0;
  v3 = (a2 & 0xFFFFFFFC) == 192;
  v4 = 0;
  v5 = a2 - 16;
  if ( v3 )
    v4 = 1;
  if ( v5 > 0xFFFFFFED )
    v2 = 1;
  return v4 | v2;
}

//----- (0000AA60) --------------------------------------------------------
int __fastcall sub_AA60(int a1, int a2)
{
  int v4; // r0

  if ( a2 > 12 )
  {
    if ( a2 != 15 )
    {
      if ( a2 == 14 )
      {
        v4 = a1 + 64;
        return *(_DWORD *)v4;
      }
      if ( a2 != 13 )
        goto LABEL_11;
LABEL_9:
      v4 = a1 + 60;
      return *(_DWORD *)v4;
    }
    goto LABEL_8;
  }
  if ( a2 == -2 )
    goto LABEL_9;
  if ( a2 == -1 )
  {
LABEL_8:
    v4 = a1 + 68;
    return *(_DWORD *)v4;
  }
LABEL_11:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
      sub_AE80(
        "uint32_t libunwind::Registers_arm::getRegister(int)",
        "external/libunwind_llvm/src/Registers.hpp",
        1452,
        "unsupported arm register");
    if ( !*(_BYTE *)(a1 + 76) )
    {
      *(_BYTE *)(a1 + 76) = 1;
      sub_A8D0();
    }
    v4 = a1 + 4 * a2 - 296;
  }
  else
  {
    v4 = a1 + 4 * a2 + 8;
  }
  return *(_DWORD *)v4;
}

//----- (0000AAEC) --------------------------------------------------------
int __fastcall sub_AAEC(int result, int a2, int a3)
{
  int v5; // r5

  v5 = result;
  if ( a2 <= 12 )
  {
    if ( a2 == -2 )
      goto LABEL_9;
    if ( a2 != -1 )
      goto LABEL_11;
LABEL_8:
    *(_DWORD *)(result + 68) = a3;
    return result;
  }
  switch ( a2 )
  {
    case 15:
      goto LABEL_8;
    case 14:
      *(_DWORD *)(result + 64) = a3;
      return result;
    case 13:
LABEL_9:
      *(_DWORD *)(result + 60) = a3;
      return result;
  }
LABEL_11:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
      sub_AE80(
        "void libunwind::Registers_arm::setRegister(int, uint32_t)",
        "external/libunwind_llvm/src/Registers.hpp",
        1471,
        "unsupported arm register");
    if ( !*(_BYTE *)(result + 76) )
    {
      *(_BYTE *)(result + 76) = 1;
      sub_A8D0();
    }
    result = v5 + 4 * a2;
    *(_DWORD *)(result - 296) = a3;
  }
  else
  {
    result += 4 * a2;
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

//----- (0000AB78) --------------------------------------------------------
int __fastcall sub_AB78(int a1, int a2)
{
  int v2; // r2
  bool v3; // zf
  int v4; // r0
  unsigned int v5; // r1

  v2 = 0;
  v3 = (a2 & 0xFFFFFFF0) == 112;
  v4 = 0;
  v5 = a2 & 0xFFFFFFE0;
  if ( v3 )
    v4 = 1;
  if ( v5 == 256 )
    v2 = 1;
  return v4 | v2;
}

//----- (0000AB9C) --------------------------------------------------------
__int64 __fastcall sub_AB9C(int a1, int a2)
{
  unsigned int v4; // r0
  _QWORD *v5; // r0
  int v6; // r0

  v4 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(a1 + 75) )
    {
      *(_BYTE *)(a1 + 75) = 1;
      sub_A88C();
    }
    v6 = a1 + 8 * a2 - 552;
  }
  else if ( v4 == 272 )
  {
    if ( !*(_BYTE *)(a1 + 74) )
    {
      *(_BYTE *)(a1 + 74) = 1;
      sub_A884((_QWORD *)(a1 + 216));
    }
    v6 = a1 + 8 * a2 - 1960;
  }
  else
  {
    if ( v4 != 256 )
      sub_AE80(
        "unw_fpreg_t libunwind::Registers_arm::getFloatRegister(int)",
        "external/libunwind_llvm/src/Registers.hpp",
        1673,
        "Unknown ARM float register");
    if ( !*(_BYTE *)(a1 + 73) )
    {
      *(_BYTE *)(a1 + 73) = 1;
      v5 = (_QWORD *)(a1 + 80);
      if ( *(_BYTE *)(a1 + 72) )
        sub_A87C(v5);
      else
        sub_A874(v5);
    }
    v6 = a1 + 8 * a2 - 1968;
  }
  return *(_QWORD *)v6;
}

//----- (0000AC40) --------------------------------------------------------
int __fastcall sub_AC40(int a1, int a2, int a3, int a4)
{
  unsigned int v6; // r0
  _QWORD *v9; // r0
  int result; // r0
  int v11; // r1

  v6 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(a1 + 75) )
    {
      *(_BYTE *)(a1 + 75) = 1;
      sub_A88C();
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 548) = a4;
    LOWORD(v11) = -552;
  }
  else if ( v6 == 272 )
  {
    if ( !*(_BYTE *)(a1 + 74) )
    {
      *(_BYTE *)(a1 + 74) = 1;
      sub_A884((_QWORD *)(a1 + 216));
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 1956) = a4;
    LOWORD(v11) = -1960;
  }
  else
  {
    if ( v6 != 256 )
      sub_AE80(
        "void libunwind::Registers_arm::setFloatRegister(int, unw_fpreg_t)",
        "external/libunwind_llvm/src/Registers.hpp",
        1700,
        "Unknown ARM float register");
    if ( !*(_BYTE *)(a1 + 73) )
    {
      *(_BYTE *)(a1 + 73) = 1;
      v9 = (_QWORD *)(a1 + 80);
      if ( *(_BYTE *)(a1 + 72) )
        sub_A87C(v9);
      else
        sub_A874(v9);
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 1964) = a4;
    LOWORD(v11) = -1968;
  }
  HIWORD(v11) = -1;
  *(_DWORD *)(result + v11) = a3;
  return result;
}

//----- (0000AD0C) --------------------------------------------------------
int __fastcall sub_AD0C(_DWORD *a1)
{
  int result; // r0
  __int64 v3; // kr00_8
  int v4; // r0

  if ( *((_BYTE *)a1 + 528) )
    return 0;
  result = sub_AEAC((int)a1);
  if ( result != 1 )
    return result;
  (*(void (__fastcall **)(_DWORD *, int))(*a1 + 52))(a1, 1);
  if ( *((_BYTE *)a1 + 528) )
    return 0;
  if ( a1[126] )
  {
    v3 = *(_QWORD *)(*a1 + 12);
    v4 = ((int (__fastcall *)(_DWORD *, int))v3)(a1, -2);
    ((void (__fastcall *)(_DWORD *, int, int))HIDWORD(v3))(a1, -2, a1[126] + v4);
  }
  return 1;
}

//----- (0000AD5C) --------------------------------------------------------
_DWORD *__fastcall sub_AD5C(int a1, _DWORD *a2)
{
  int *v2; // r0
  _DWORD *result; // r0
  int v4; // r2
  int v5; // r3
  int v6; // r4
  int v7; // r12
  int v8; // lr
  _DWORD *v9; // r1
  int v10; // r3
  int v11; // r4
  int v12; // r12
  int v13; // lr

  v2 = (int *)(a1 + 488);
  v4 = *v2;
  v5 = v2[1];
  v6 = v2[2];
  v7 = v2[3];
  v8 = v2[4];
  result = v2 + 5;
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  a2[4] = v8;
  v9 = a2 + 5;
  v10 = result[1];
  v11 = result[2];
  v12 = result[3];
  v13 = result[4];
  *v9 = *result;
  v9[1] = v10;
  v9[2] = v11;
  v9[3] = v12;
  v9[4] = v13;
  return result;
}

//----- (0000AD74) --------------------------------------------------------
int __fastcall sub_AD74(int a1)
{
  int v1; // r4

  v1 = a1 + 8;
  sub_AF00(a1 + 8);
  return sub_B640(v1);
}

//----- (0000AD8A) --------------------------------------------------------
int __fastcall sub_AD8A(int a1)
{
  return *(unsigned __int8 *)(a1 + 529);
}

//----- (0000AD90) --------------------------------------------------------
int __fastcall sub_AD90(int a1, int a2, int a3, _DWORD *a4)
{
  int v7; // r7
  char v9[8]; // [sp+8h] [bp-28h] BYREF
  const char *v10; // [sp+10h] [bp-20h]
  int v11; // [sp+14h] [bp-1Ch]

  v7 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, -1);
  if ( !dladdr(v7, v9) || !v10 )
    return 0;
  _snprintf_chk(a2, a3, 0, -1, "%s", v10);
  *a4 = v7 - v11;
  return 1;
}
// 3158: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 34DC: using guessed type int __fastcall dladdr(_DWORD, _DWORD);
// AD90: using guessed type char var_28[8];

//----- (0000AE00) --------------------------------------------------------
int __fastcall sub_AE00(int *a1, int a2)
{
  int v4; // r5
  int v6[2]; // [sp+0h] [bp-20h] BYREF
  int v7[6]; // [sp+8h] [bp-18h] BYREF

  v4 = (*(int (__fastcall **)(int *, int))(*a1 + 12))(a1, -1) & 0xFFFFFFFE;
  v7[0] = 0;
  if ( a2 )
    --v4;
  v6[0] = _gnu_Unwind_Find_exidx(v4, v7);
  v6[1] = v7[0];
  if ( !v6[0] || !v7[0] || !sub_AF58(a1, v4, v6) )
    *((_BYTE *)a1 + 528) = 1;
  return _stack_chk_guard - v7[1];
}
// 34E8: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);

//----- (0000AE76) --------------------------------------------------------
int __fastcall sub_AE76(int result)
{
  *(_BYTE *)(result + 72) = 1;
  return result;
}

//----- (0000AE80) --------------------------------------------------------
void __fastcall __noreturn sub_AE80(const char *a1, const char *a2, int a3, const char *a4)
{
  fprintf(stderr, "libunwind: %s %s:%d - %s\n", a1, a2, a3, a4);
  abort();
}

//----- (0000AEAC) --------------------------------------------------------
int __fastcall sub_AEAC(int a1)
{
  int v2; // r4
  unsigned int *v3; // r0
  unsigned int v5; // [sp+4h] [bp-1Ch] BYREF
  unsigned int v6; // [sp+8h] [bp-18h] BYREF

  v2 = 0;
  v5 = 0;
  v6 = 0;
  v3 = sub_9FE0(*(unsigned int **)(a1 + 520), (int *)&v5, (int *)&v6);
  if ( sub_A034(a1, (int)v3, v5, v6) == 8 )
    return 1;
  return v2;
}

//----- (0000AF00) --------------------------------------------------------
_DWORD *__fastcall sub_AF00(int a1)
{
  int v2; // r0
  _DWORD *result; // r0

  if ( *(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(a1 + 64) )
      sub_B5A8();
    else
      sub_B5A0();
  }
  if ( (unsigned __int8)*(_WORD *)(a1 + 66) )
  {
    sub_B5B0();
    v2 = *(unsigned __int8 *)(a1 + 67);
  }
  else
  {
    v2 = HIBYTE(*(unsigned __int16 *)(a1 + 66));
  }
  if ( v2 )
    sub_B5B8((int *)(a1 + 336));
  result = (_DWORD *)*(unsigned __int8 *)(a1 + 68);
  if ( *(_BYTE *)(a1 + 68) )
    return sub_B650((int *)(a1 + 464));
  return result;
}

//----- (0000AF58) --------------------------------------------------------
int __fastcall sub_AF58(int *a1, int a2, _DWORD *a3)
{
  int v4; // r5
  int v5; // r6
  char *v6; // r1
  int *v7; // r0
  int v8; // r5
  int v9; // r7
  unsigned int v10; // r6
  int v11; // r12
  int (__fastcall *v12)(int, int, int); // lr
  int v13; // r9
  int v14; // r6
  int v15; // r6
  int v16; // r3
  int v17; // r7
  int v19[3]; // [sp+14h] [bp-34h] BYREF
  int v20; // [sp+20h] [bp-28h] BYREF

  v4 = 0;
  v20 = a2;
  v5 = a3[1];
  sub_B0FC(v19, 0, a1[1], a3, v5, a1[1], (int)a3, &v20);
  if ( !v19[0] || v19[0] == v5 )
    return v4;
  v6 = (char *)(*(_DWORD *)v19[2] + 8 * v19[0]);
  v7 = (int *)(v6 - 4);
  v8 = *(_DWORD *)v6;
  if ( v6 == &byte_4 )
    return 0;
  v9 = *v7;
  if ( *v7 == 1 )
    return 0;
  if ( v9 < 0 )
  {
    v11 = 1;
    goto LABEL_11;
  }
  v10 = (2 * v9) & 0x80000000 | v9;
  v9 = *(int *)((char *)v7 + v10);
  v7 = (int *)((char *)v7 + v10);
  if ( v9 <= -1 )
  {
    v11 = 0;
LABEL_11:
    v14 = HIBYTE(v9) & 0xF;
    if ( v14 == 2 )
    {
      v12 = sub_A5BC;
      v15 = 1;
    }
    else
    {
      if ( v14 != 1 )
      {
        if ( v14 )
          sub_AE80(
            "bool libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm>::getInfoFromEHABISectio"
            "n(pint_t, const libunwind::UnwindInfoSections &) [A = libunwind::LocalAddressSpace, R = libunwind::Registers_arm]",
            "external/libunwind_llvm/src/UnwindCursor.hpp",
            776,
            "unknown personality routine");
        v13 = (int)(v7 + 1);
        if ( v11 )
          v13 = 0;
        v12 = sub_A550;
        goto LABEL_17;
      }
      v12 = sub_A5B4;
      v15 = 0;
    }
    v16 = BYTE2(v9);
    v17 = v16;
    if ( v16 )
      v17 = 1;
    if ( (v17 & v11) == 1 )
      sub_AE80(
        "bool libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm>::getInfoFromEHABISection(pi"
        "nt_t, const libunwind::UnwindInfoSections &) [A = libunwind::LocalAddressSpace, R = libunwind::Registers_arm]",
        "external/libunwind_llvm/src/UnwindCursor.hpp",
        783,
        "index inlined table detected but pr function requires extra words");
    v13 = (int)&v7[v16 + 1];
    goto LABEL_24;
  }
  v11 = 0;
  v12 = (int (__fastcall *)(int, int, int))((char *)v7 + (v9 | (2 * v9) & 0x80000000));
  v13 = (int)&v7[HIBYTE(v7[1]) + 2];
LABEL_17:
  v15 = 0;
LABEL_24:
  a1[122] = (int)&v6[((2 * *((_DWORD *)v6 - 2)) & 0x80000000 | *((_DWORD *)v6 - 2)) - 8];
  a1[123] = (int)&v6[v8 | (2 * v8) & 0x80000000];
  v4 = 1;
  a1[130] = (int)v7;
  a1[124] = v13;
  a1[125] = (int)v12;
  if ( v15 )
    v15 = 2;
  if ( v11 )
    v15 = 1;
  a1[127] = v15;
  return v4;
}
// 4: using guessed type char byte_4;

//----- (0000B0FC) --------------------------------------------------------
_DWORD *__fastcall sub_B0FC(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8)
{
  unsigned int v8; // r4
  unsigned int v9; // r5
  int v10; // r6

  v8 = a5 - a2;
  while ( 1 )
  {
    v9 = v8;
    if ( !v8 )
      break;
    v10 = a2 + (v8 >> 1);
    v8 >>= 1;
    if ( *a8 >= *a4 + 8 * v10 + ((2 * *(_DWORD *)(*a4 + 8 * v10)) & 0x80000000 | *(_DWORD *)(*a4 + 8 * v10)) )
    {
      v8 = v9 - 1 - v8;
      a2 = v10 + 1;
    }
  }
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  return a1 + 3;
}

//----- (0000B58C) --------------------------------------------------------
int __fastcall sub_B58C(int a1)
{
  return (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 60))(
           *(_DWORD *)a1,
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)(a1 + 8),
           *(_DWORD *)(a1 + 12));
}

//----- (0000B5A0) --------------------------------------------------------
void sub_B5A0()
{
  ;
}

//----- (0000B5A8) --------------------------------------------------------
void sub_B5A8()
{
  ;
}

//----- (0000B5B0) --------------------------------------------------------
void sub_B5B0()
{
  ;
}

//----- (0000B5B8) --------------------------------------------------------
_DWORD *__fastcall sub_B5B8(int *a1)
{
  int *v5; // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = v5 + 2;
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (0000B5FC) --------------------------------------------------------
_DWORD *__fastcall sub_B5FC(int *a1)
{
  int *v5; // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = v5 + 1;
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (0000B610) --------------------------------------------------------
// attributes: thunk
void __fastcall j_free(void *ptr)
{
  free(ptr);
}

//----- (0000B620) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (0000B630) --------------------------------------------------------
// attributes: thunk
char *__fastcall j_strdup(const char *s)
{
  return strdup(s);
}

//----- (0000B640) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_B640(int a1)
{
  return sub_B58C(a1);
}

//----- (0000B650) --------------------------------------------------------
// attributes: thunk
_DWORD *__fastcall sub_B650(int *a1)
{
  return sub_B5FC(a1);
}

// nfuncs=396 queued=185 decompiled=185 lumina nreq=0 worse=0 better=0
// ALL OK, 185 function(s) have been successfully decompiled
